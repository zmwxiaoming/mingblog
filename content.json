{"meta":{"title":"JET明","subtitle":"永远前进","description":"会当凌绝顶，一览众山小。","author":"小明","url":"https://www.iteway.com"},"pages":[{"title":"","date":"2019-09-25T01:15:46.169Z","updated":"2018-01-04T14:42:35.000Z","comments":true,"path":"baidu_verify_M2SOgzR25m.html","permalink":"https://www.iteway.com/baidu_verify_M2SOgzR25m.html","excerpt":"","text":"M2SOgzR25m"},{"title":"分类","date":"2018-01-03T06:20:52.000Z","updated":"2018-01-04T04:10:55.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.iteway.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-01-03T06:21:10.000Z","updated":"2018-01-30T09:59:32.000Z","comments":true,"path":"about/index.html","permalink":"https://www.iteway.com/about/index.html","excerpt":"","text":"但愿人长久 公众号与小程序 公众号 小程序 友情链接且听书吟 人称”学姐”的神秘人物,博客内容很有思想 Alexinea 读书超级多,爱写读书笔记的程序员 99° 暂无描述"},{"title":"所有标签","date":"2018-01-03T11:35:49.000Z","updated":"2018-01-04T04:10:09.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.iteway.com/tags/index.html","excerpt":"","text":""},{"title":"日程表","date":"2018-01-04T04:00:08.000Z","updated":"2018-01-04T04:07:31.000Z","comments":true,"path":"schedule/index.html","permalink":"https://www.iteway.com/schedule/index.html","excerpt":"","text":"暂无"}],"posts":[{"title":"Docker实战","slug":"Docker实战","date":"2020-10-27T07:10:46.384Z","updated":"2020-10-28T06:29:22.054Z","comments":true,"path":"2020/10/27/Docker实战/","link":"","permalink":"https://www.iteway.com/2020/10/27/Docker实战/","excerpt":"","text":"","categories":[{"name":"Docker","slug":"Docker","permalink":"https://www.iteway.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.iteway.com/tags/Docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"https://www.iteway.com/categories/Docker/"}]},{"title":"Java8 Stream介绍","slug":"Java8 Stream介绍","date":"2020-10-27T07:03:20.055Z","updated":"2021-05-28T08:28:18.929Z","comments":true,"path":"2020/10/27/Java8 Stream介绍/","link":"","permalink":"https://www.iteway.com/2020/10/27/Java8 Stream介绍/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076/** *filter使用,找到第一个,找不到返回null, */ @Test public void streamTest() &#123; List&lt;String&gt; lists = Lists.newArrayList(null, null, \"bb\", \"cc\"); String str = lists.stream().filter(st -&gt; \"aa\".equals(st)).findFirst().orElse(null); System.out.println(str); &#125; @Test public void testOptional() &#123; //没有删除方法 List&lt;String&gt; names = Arrays.asList(\"Mal\", \"Wash\", \"Kaylee\", \"Inara\", \"Zoë\", \"Jayne\", \"Simon\", \"River\", \"Shepherd Book\", \"CA\"); Optional&lt;String&gt; first = names.stream().filter(name -&gt; name.startsWith(\"C\")).findFirst(); System.out.println(first); System.out.println(first.orElse(\"None\")); System.out.println(first.orElse(getFormat(names))); System.out.println(first.orElseGet(() -&gt; getFormat(names))); System.out.println(first.orElseThrow(() -&gt; new NullPointerException(\"异常\"))); &#125; private String getFormat(List&lt;String&gt; names) &#123; System.out.println(names); return String.format(\"No result found in %s\", names.stream().collect(Collectors.joining(\", \"))); &#125; @Test public void testPredicate() &#123; List&lt;String&gt; names = Lists.newArrayList(\"Mal\", \"Wash\", \"Kaylee\", \"Inara\", \"Zoë\", \"Jayne\", \"Simon\", \"River\", null, \"Shepherd Book\", \"CA\"); Predicate&lt;String&gt; predicate = s -&gt; s != null; predicate = predicate.and(s -&gt; s.length() == 5); System.out.println(getNamesOfLength(predicate, names)); System.out.println(names.removeIf(s -&gt; s == null || s.length() == 5)); System.out.println(names); &#125; private String getNamesOfLength(Predicate&lt;String&gt; predicate, List&lt;String&gt; names) &#123; return names.stream().filter(predicate).collect(Collectors.joining(\", \")); &#125; @Test public void testFunction() &#123; ArrayList&lt;String&gt; names = Lists.newArrayList(\"Mal\", \"Wash\", \"Kaylee\", \"Inara\", \"Zoë\", \"Jayne\", \"Simon\", \"River\", \"Shepherd Book\"); //匿名内部类 List&lt;Integer&gt; nameLengths2 = names.stream().map(new Function&lt;String, Integer&gt;() &#123; @Override public Integer apply(String s) &#123; return s.length(); &#125; &#125;).collect(toList()); //lambda表达式 List&lt;Integer&gt; nameLengths = names.stream().map(s -&gt; s.length()).collect(toList()); //方法引用 List&lt;Integer&gt; nameLengths1 = names.stream().map(String::length).collect(toList()); System.out.println(nameLengths); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"11\", 1); map.computeIfPresent(\"11\", (k, v) -&gt; v = v + 1); System.out.println(map); &#125; @Test public void testStream() &#123; Stream.generate(Math::random).limit(10).forEach(System.out::println); List&lt;Integer&gt; ints = IntStream.range(10, 15).boxed().collect(toList()); System.out.println(ints); List&lt;Integer&gt; ints2 = IntStream.rangeClosed(10, 15).boxed().collect(toList()); List&lt;Integer&gt; ints3 = IntStream.rangeClosed(10, 15).mapToObj(Integer::valueOf).collect(toList()); System.out.println(ints2); &#125; @Test public void testCollect() &#123; List&lt;Integer&gt; ints = IntStream.of(3, 1, 4, 1, 5, 9) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll); System.out.println(ints); int[] intArray = IntStream.of(3, 1, 4, 1, 5, 9).toArray(); System.out.println(Arrays.toString(intArray)); &#125; /**统计的api**/ @Test public void testCount() &#123; String[] strings = \"this is an array of strings\".split(\" \"); long count = Arrays.stream(strings).map(String::length).count(); System.out.println(count); int totalLength = Arrays.stream(strings).mapToInt(String::length).sum(); System.out.println(totalLength); OptionalDouble ave = Arrays.stream(strings).mapToInt(String::length).average(); System.out.println(ave.getAsDouble()); System.out.println(Double.NaN); OptionalInt max = Arrays.stream(strings).mapToInt(String::length).max(); System.out.println(max.getAsInt()); OptionalInt min = Arrays.stream(strings).mapToInt(String::length).min(); System.out.println(min.getAsInt()); int sum = Arrays.stream(strings).mapToInt(String::length).reduce((x, y) -&gt; x + y).orElse(0); System.out.println(sum); &#125; /**String字符串拼接*/ @Test public void testReduceStrJoin1() &#123; String s = Stream.of(\"this\", \"is\", \"a\", \"list\") .collect(() -&gt; new StringBuilder(), (sb, str) -&gt; sb.append(str), (sb1, sb2) -&gt; sb1.append(sb2)) .toString(); System.out.println(s); &#125; /**其他类型的可以通过StringUtils进行拼接:List&lt;Long&gt; teacherIds = Lists.newArrayList(12L,13L,18L);String teacherIdsStr = StringUtils.join(teacherIds.iterator(), \",\");**/ @Test public void testReduceStrJoin2() &#123; String s = Stream.of(\"this\", \"is\", \"a\", \"list\") .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append) .toString(); System.out.println(s); &#125; @Test public void testReduceStrJoin3() &#123; String s = Stream.of(\"this\", \"is\", \"a\", \"list\") .collect(Collectors.joining()); System.out.println(s); &#125; @Test public void testReducePrim() &#123; List&lt;Book&gt; books = Lists.newArrayList( new Book(1, \"Java 1\"), new Book(1, \"Java 2\"), new Book(3, \"Java 3\"), new Book(4, \"Java 4\") ); HashMap&lt;Integer, Book&gt; bookMap = books.stream() .reduce(new HashMap&lt;&gt;(), (map, book) -&gt; &#123; map.put(book.getId(), book); return map; &#125;, (map1, map2) -&gt; &#123; map1.putAll(map2); return map1; &#125;); bookMap.forEach((k, v) -&gt; System.out.println(k + \": \" + v)); &#125;/***List 变 map*Collectors.toMap(Book::getId, b -&gt; b) 第一个参数是key,第二个是value, 不允许有重复的*下面允许将重复的保留第几个*Collectors.toMap(Book::getId, Function.identity(), (k1, k2) -&gt; k2)*/ @Test public void testReducetoMap() &#123; List&lt;Book&gt; books = Lists.newArrayList( new Book(1, \"Java 1\"), new Book(1, \"Java 2\"), new Book(3, \"Java 3\"), new Book(4, \"Java 4\") ); //不允许重复的 //Map&lt;Integer, Book&gt; bookMap = books.stream().collect(Collectors.toMap(Book::getId, b -&gt; b)); //重复的归并到第二个 Map&lt;Integer, Book&gt; bookMap = books.stream().collect(Collectors.toMap(Book::getId, Function.identity(), (k1, k2) -&gt; k2)); bookMap.forEach((k, v) -&gt; System.out.println(k + \": \" + v)); &#125; //reduce操作 @Test public void testReduceSum() &#123; BigDecimal total = Stream.iterate(BigDecimal.ONE, n -&gt; n.add(BigDecimal.ONE)) .limit(10) .reduce(BigDecimal.ZERO, (acc, val) -&gt; acc.add(val)); System.out.println(\"The total is \" + total); &#125; @Test public void testReduceSort() &#123; List&lt;String&gt; strings = Lists.newArrayList( \"this\", \"is\", \"a\", \"list\", \"of\", \"strings\"); List&lt;String&gt; sorted = strings.stream() .sorted(Comparator.comparingInt(String::length)) .collect(toList()); System.out.println(sorted); sorted.stream() .reduce((prev, curr) -&gt; &#123; assertTrue(prev.length() &lt;= curr.length()); return curr; &#125;); &#125; @Test public void sumDoublesDivisibleBy3() &#123; assertEquals(1554, sumDoublesDivisibleBy3(100, 120)); &#125; public int sumDoublesDivisibleBy3(int start, int end) &#123; return IntStream.rangeClosed(start, end) .peek(n -&gt; System.out.printf(\"original: %d%n\", n)) .map(n -&gt; n * 2) .peek(n -&gt; System.out.printf(\"doubled: %d%n\", n)) .filter(n -&gt; n % 3 == 0) .peek(n -&gt; System.out.printf(\"filtered: %d%n\", n)) .sum(); &#125; @Test public void testPalindrome() &#123; String str = \"asisA\"; System.out.println(isPalindrome1(str)); &#125; public boolean isPalindrome(String s) &#123; StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) &#123; if (Character.isLetterOrDigit(c)) &#123; sb.append(c); &#125; &#125; String forward = sb.toString().toLowerCase(); String backward = sb.reverse().toString().toLowerCase(); return forward.equals(backward); &#125; public boolean isPalindrome1(String s) &#123; String forward = s.toLowerCase().codePoints() .filter(Character::isLetterOrDigit) .peek(n -&gt; System.out.println(n)) .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append) .toString(); String backward = new StringBuilder(forward).reverse().toString(); return forward.equals(backward); &#125; /** * count是一种特殊的归约,相当于 * long count = Stream.of(3, 1, 4, 1, 5, 9, 2, 6, 5).mapToLong(e-&gt;1L).sum(); * return mapToLong(e -&gt; 1L).sum(); */ @Test public void testItemsCount() &#123; long count = Stream.of(3, 1, 4, 1, 5, 9, 2, 6, 5).count(); System.out.printf(\"There are %d elements in the stream%n\", count); &#125; /** * Function.identity() 也就是 return t -&gt; t; */ @Test public void testD() &#123; List&lt;Book&gt; books = Lists.newArrayList( new Book(1, \"Java 1\"), new Book(1, \"Java 2\"), new Book(3, \"Java 3\"), new Book(4, \"Java 4\") ); Map&lt;Integer, Book&gt; bookMap = books.stream().collect(Collectors.toMap(b -&gt; b.getId(), Function.identity(), (k1, k2) -&gt; k2)); System.out.println(bookMap); &#125; @Test public void testPartitioning() &#123; List&lt;String&gt; strings = Lists.newArrayList( \"this\", \"is\", \"a\", \"list\", \"of\", \"strings\"); Map&lt;Boolean, Long&gt; numberLengthMap = strings.stream() .collect(Collectors.partitioningBy( s -&gt; s.length() % 2 == 0, Collectors.counting())); Map&lt;Boolean, List&lt;String&gt;&gt; stringsPartitionMap = strings.stream() .collect(Collectors.partitioningBy( s -&gt; s.length() % 2 == 0)); numberLengthMap.forEach((k, v) -&gt; System.out.printf(\"%5s: %d%n\", k, v)); System.out.println(stringsPartitionMap); &#125; /** * 用户希望获取数值流中元素的数量、总和、最小值、最大值以及平均值。 */ @Test public void testSummaryStatistics() &#123; //DoubleStream.generate(Math::random) List&lt;Double&gt; doubleList = Lists.newArrayList(1.0, 2.1, 3.4); DoubleSummaryStatistics stats = doubleList.stream().mapToDouble(d -&gt; d) .summaryStatistics(); System.out.println(stats); System.out.println(\"count: \" + stats.getCount()); System.out.println(\"min : \" + stats.getMin()); System.out.println(\"max : \" + stats.getMax()); System.out.println(\"sum : \" + stats.getSum()); System.out.println(\"ave : \" + stats.getAverage()); &#125; @Test public void testOptionalFindFirst() &#123; Optional&lt;Integer&gt; firstEvenGT10 = Stream.of(3, 1, 4, 1, 5, 9, 2, 6, 5) .peek(i -&gt; System.out.println(i)) .filter(n -&gt; n % 2 == 0) .findFirst(); System.out.println(firstEvenGT10); &#125; @Test public void testHash() &#123; List&lt;String&gt; wordList = Arrays.asList( \"this\", \"is\", \"a\", \"stream\", \"of\", \"strings\"); Set&lt;String&gt; words = new HashSet&lt;&gt;(wordList); Set&lt;String&gt; words2 = new HashSet&lt;&gt;(words); // 接下来，添加和删除足够多的元素来强制进行再散列操作 IntStream.rangeClosed(0, 50).forEachOrdered(i -&gt; words2.add(String.valueOf(i))); words2.retainAll(wordList); // 这些集合是相等的，但具有不同的元素排序 System.out.println(words.equals(words2)); System.out.println(\"Before: \" + words); System.out.println(\"After : \" + words2); &#125; @Test public void testFindAny() &#123; Optional&lt;Integer&gt; any = Stream.of(3, 1, 4, 1, 5, 9, 2, 6, 5) .unordered() .parallel() .map(this::delay) .findAny(); System.out.println(\"Any: \" + any); &#125; public Integer delay(Integer n) &#123; try &#123; Thread.sleep((long) (Math.random() * 100)); &#125; catch (InterruptedException ignored) &#123; &#125; return n; &#125; public boolean isPrime(int num) &#123; int limit = (int) Math.sqrt(num) + 1; return num == 2 || num &gt; 1 &amp;&amp; IntStream.range(2, limit).noneMatch(divisor -&gt; num % divisor == 0); &#125; @Test public void testIsPrimeUsingAllMatch() throws Exception &#123; assertTrue(IntStream.of(2, 3, 5, 7, 11, 13, 17, 19) .allMatch(i -&gt; isPrime(i))); &#125; @Test public void testIsPrimeWithComposites() throws Exception &#123; assertFalse(Stream.of(4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20) .anyMatch(i -&gt; isPrime(i))); &#125; @Test public void emptyStreamsDanger() &#123; assertTrue(Stream.empty().allMatch(e -&gt; false)); assertTrue(Stream.empty().noneMatch(e -&gt; true)); assertFalse(Stream.empty().anyMatch(e -&gt; true)); &#125; @Test public void testFlatMap() &#123; Customer sheridan = new Customer(\"Sheridan\"); Customer ivanova = new Customer(\"Ivanova\"); Customer garibaldi = new Customer(\"Garibaldi\"); sheridan.addOrder(new Order(1)) .addOrder(new Order(2)) .addOrder(new Order(3)); ivanova.addOrder(new Order(4)) .addOrder(new Order(5)); List&lt;Customer&gt; customers = Lists.newArrayList(sheridan, ivanova, garibaldi); customers.stream().map(Customer::getName).forEach(System.out::println); customers.stream() .map(Customer::getOrders) .forEach(System.out::println); customers.stream() .map(customer -&gt; customer.getOrders().stream()) .forEach(System.out::println); customers.stream() .flatMap(customer -&gt; customer.getOrders().stream()) .forEach(System.out::println); &#125; @Test public void testStreamConcat() &#123; Stream&lt;String&gt; first = Stream.of(\"a\", \"b\", \"c\").parallel(); Stream&lt;String&gt; second = Stream.of(\"X\", \"Y\", \"Z\"); Stream&lt;String&gt; third = Stream.of(\"alpha\", \"beta\", \"gamma\"); Stream&lt;String&gt; fourth = Stream.empty(); List&lt;String&gt; strings = Stream.of(first, second, third, fourth) .reduce(Stream.empty(), Stream::concat) .collect(Collectors.toList()); System.out.println(strings); &#125; @Test public void flatMap() &#123; Stream&lt;String&gt; first = Stream.of(\"a\", \"b\", \"c\").parallel(); Stream&lt;String&gt; second = Stream.of(\"X\", \"Y\", \"Z\"); Stream&lt;String&gt; third = Stream.of(\"alpha\", \"beta\", \"gamma\"); Stream&lt;String&gt; fourth = Stream.empty(); List&lt;String&gt; strings = Stream.of(first, second, third, fourth) .flatMap(Function.identity()) .collect(Collectors.toList()); List&lt;String&gt; stringList = Arrays.asList(\"a\", \"b\", \"c\", \"X\", \"Y\", \"Z\", \"alpha\", \"beta\", \"gamma\"); assertEquals(stringList, strings); &#125; @Test public void flatMapParallel() &#123; Stream&lt;String&gt; first = Stream.of(\"a\", \"b\", \"c\").parallel(); Stream&lt;String&gt; second = Stream.of(\"X\", \"Y\", \"Z\"); Stream&lt;String&gt; third = Stream.of(\"alpha\", \"beta\", \"gamma\"); Stream&lt;String&gt; fourth = Stream.empty(); Stream&lt;String&gt; total = Stream.of(first, second, third, fourth) .flatMap(Function.identity()); assertFalse(total.isParallel()); total = total.parallel(); assertTrue(total.isParallel()); &#125; @Test public void testFilter() &#123; List&lt;Book&gt; books = Lists.newArrayList( new Book(1, \"Java 1\"), new Book(1, null), new Book(3, null), new Book(4, \"Java 4\") ); List&lt;Book&gt; booksFilter = books.stream().filter(t -&gt; t.getId() != 1 &amp;&amp; t.getTitle() != null).collect(Collectors.toList()); System.out.println(booksFilter); &#125; @Test public void testToSet() &#123; List&lt;String&gt; actors = Stream.of(\"Hank Azaria\", \"Janeane Garofalo\", \"William H. Macy\", \"Paul Reubens\", \"Ben Stiller\", \"Kel Mitchell\", \"Wes Studi\") .collect(Collectors.toCollection(LinkedList::new)); System.out.println(actors); &#125; @Test public void testToArray() &#123; String[] actors = Stream.of(\"Hank Azaria\", \"Janeane Garofalo\", \"William H. Macy\", \"Paul Reubens\", \"Ben Stiller\", \"Kel Mitchell\", \"Wes Studi\").toArray(String[]::new); System.out.println(actors); &#125; @Test public void testMap() &#123; Set&lt;Book&gt; books = Sets.newHashSet( new Book(1, \"A Java 1\"), new Book(1, \"C Java 2\"), new Book(3, \"D Java 3\"), new Book(4, \"B Java 4\")); Map&lt;Integer, String&gt; bookMap = books.stream() .collect(Collectors.toMap(Book::getId, Book::getTitle, (k1, k2) -&gt; k2)); bookMap.entrySet().stream().sorted(Map.Entry.comparingByKey(Comparator.reverseOrder())). forEach(entry -&gt; System.out.printf(\"%s name %s%n\", entry.getKey(), entry.getValue())); &#125; /** * 分区, 满足predicate的, 不满足predicate的 */ @Test public void testPartition() &#123; List&lt;String&gt; strings = Arrays.asList(\"this\", \"is\", \"a\", \"long\", \"list\", \"of\", \"strings\", \"to\", \"use\", \"as\", \"a\", \"demo\"); Map&lt;Boolean, List&lt;String&gt;&gt; lengthMap = strings.stream() .collect(Collectors.partitioningBy(s -&gt; s.length() % 2 == 0)); lengthMap.forEach((key, value) -&gt; System.out.printf(\"%5s: %s%n\", key, value)); &#125; /** * 下游收集器 */ @Test public void testPartitionDownStream() &#123; List&lt;String&gt; strings = Arrays.asList(\"this\", \"is\", \"a\", \"long\", \"list\", \"of\", \"strings\", \"to\", \"use\", \"as\", \"a\", \"demo\"); Map&lt;Boolean, Long&gt; lengthNum = strings.stream() .collect(Collectors.partitioningBy(s -&gt; s.length() % 2 == 0, Collectors.counting())); lengthNum.forEach((key, value) -&gt; System.out.printf(\"%5s: %s%n\", key, value)); &#125; @Test public void testGrouping() &#123; List&lt;String&gt; strings = Arrays.asList(\"this\", \"is\", \"a\", \"long\", \"list\", \"of\", \"strings\", \"to\", \"use\", \"as\", \"a\", \"demo\"); Map&lt;Integer, List&lt;String&gt;&gt; lengthMap = strings.stream() .collect(Collectors.groupingBy(String::length)); lengthMap.forEach((k, v) -&gt; System.out.printf(\"%d: %s%n\", k, v)); &#125; @Test public void testMinMax() &#123; List&lt;Employee&gt; employees = Arrays.asList( new Employee(\"Cersei\", 250_000, \"Lannister\"), new Employee(\"Jamie\", 150_000, \"Lannister\"), new Employee(\"Tyrion\", 1_000, \"Lannister\"), new Employee(\"Tywin\", 1_000_000, \"Lannister\"), new Employee(\"Jon Snow\", 75_000, \"Stark\"), new Employee(\"Robb\", 120_000, \"Stark\"), new Employee(\"Eddard\", 125_000, \"Stark\"), new Employee(\"Sansa\", 0, \"Stark\"), new Employee(\"Arya\", 1_000, \"Stark\")); Employee defaultEmployee = new Employee(\"A man (or woman) has no name\", 0, \"Black and White\"); Optional&lt;Employee&gt; optionalEmp = employees.stream() .collect(Collectors.maxBy(Comparator.comparingInt(Employee::getSalary))); System.out.println(optionalEmp); Map&lt;String, Optional&lt;Employee&gt;&gt; groupByPartment = employees.stream() .collect(Collectors.groupingBy( Employee::getDepartment, Collectors.maxBy(Comparator.comparingInt(Employee::getSalary)))); System.out.println(groupByPartment); &#125; @Test public void testUnmodifyable() &#123; Map&lt;String, Integer&gt; map = Collections.unmodifiableMap( new HashMap&lt;String, Integer&gt;() &#123;&#123; put(\"have\", 1); put(\"the\", 2); put(\"high\", 3); put(\"ground\", 4); &#125;&#125;); &#125; &#125; class Employee &#123; private String name; private Integer salary; private String department; // 其他方法 public Employee(String name, Integer salary, String department) &#123; this.name = name; this.salary = salary; this.department = department; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getSalary() &#123; return salary; &#125; public void setSalary(Integer salary) &#123; this.salary = salary; &#125; public String getDepartment() &#123; return department; &#125; public void setDepartment(String department) &#123; this.department = department; &#125; @Override public String toString() &#123; return \"Employee&#123;\" + \"name='\" + name + '\\'' + \", salary=\" + salary + \", department='\" + department + '\\'' + '&#125;'; &#125;&#125; class Book &#123; private Integer id; private String title; // 构造函数、getter和setter、toString、equals、hashCode… public Book() &#123; &#125; public Book(Integer id, String title) &#123; this.id = id; this.title = title; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; @Override public String toString() &#123; return \"Book&#123;\" + \"id=\" + id + \", title='\" + title + '\\'' + '&#125;'; &#125;&#125; class Customer &#123; private String name; private List&lt;Order&gt; orders = new ArrayList&lt;&gt;(); public Customer(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public List&lt;Order&gt; getOrders() &#123; return orders; &#125; public Customer addOrder(Order order) &#123; orders.add(order); return this; &#125;&#125; class Order &#123; private int id; public Order(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125; @Override public String toString() &#123; return \"Order&#123;\" + \"id=\" + id + '&#125;'; &#125;&#125; package com.east.service; import com.google.common.collect.Lists;import com.google.common.collect.Maps;import org.junit.Test; import java.io.IOException;import java.math.BigInteger;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.time.*;import java.util.*;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;import java.util.logging.Logger;import java.util.stream.Collectors;import java.util.stream.Stream; import static junit.framework.TestCase.assertTrue; /** * @author zhaomingwei * Created on 18/9/20. */public class Lambda2Test &#123; @Test public void testObjectNonNull() &#123; List&lt;String&gt; strings = Arrays.asList( \"this\", null, \"is\", \"a\", null, \"list\", \"of\", \"strings\", null); List&lt;String&gt; nonNullStrings = strings.stream() .filter(Objects::nonNull) .collect(Collectors.toList()); System.out.println(nonNullStrings); List&lt;String&gt; strings2 = Arrays.asList(\"this\", \"is\", \"a\", \"list\", \"of\", \"strings\"); assertTrue(Objects.deepEquals(strings2, nonNullStrings)); assertTrue(strings2.equals(nonNullStrings)); &#125; /** * 从泛型中去掉空元素 * * @param list * @param &lt;T&gt; * * @return */ public &lt;T&gt; List&lt;T&gt; getNonNullElements(List&lt;T&gt; list) &#123; return list.stream() .filter(Objects::nonNull) .collect(Collectors.toList()); &#125; @Test public void testRequireNonNull() &#123; String s = null; Objects.requireNonNull(s, () -&gt; \"不能为空\"); &#125; private Map&lt;Long, BigInteger&gt; cache = new HashMap&lt;&gt;(); @Test public void testMapNew() &#123; long time1 = System.nanoTime(); fib(70); long time2 = System.nanoTime(); System.out.println(time2 - time1); //fib2(70); long time3 = System.nanoTime(); System.out.println(time3 - time2); System.out.println(cache); &#125; //computeIfAbsent如果键存在，返回对应的值，否则通过提供的函数计算新的值并保存 public BigInteger fib(long i) &#123; if (i == 0) &#123; return BigInteger.ZERO; &#125; else if (i == 1) &#123; return BigInteger.ONE; &#125; return cache.computeIfAbsent(i, n -&gt; fib(n - 2).add(fib(n - 1))); &#125; //巨慢 public long fib2(long i) &#123; if (i == 0) &#123; return 0; &#125; else if (i == 1) &#123; return 1; &#125; return fib2(i - 2) + fib2(i - 1); &#125; @Test public void testMapPresent() &#123; String sentence = \"hello world hello kitty\"; String[] strings = sentence.split(\" \"); Map&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;(); Arrays.stream(strings).forEach(s -&gt; wordCount.merge(s, 1, Integer::sum)); System.out.println(wordCount); &#125; //冲突 public interface Company &#123; default String getName() &#123; return \"Initech\"; &#125; // 其他方法 &#125; public interface Employee &#123; String getFirst(); String getLast(); void convertCaffeineToCodeForMoney(); default String getName() &#123; return String.format(\"%s %s\", getFirst(), getLast()); &#125; &#125; public class CompanyEmployee implements Company, Employee &#123; private String first; private String last; @Override public void convertCaffeineToCodeForMoney() &#123; System.out.println(\"Coding...\"); &#125; @Override public String getFirst() &#123; return first; &#125; @Override public String getLast() &#123; return last; &#125; @Override public String getName() &#123; return String.format(\"%s %s\", Employee.super.getName(), Company.super.getName()); &#125; &#125; //Function 接口定义的复合方法 @Test public void testFunctionCompose() &#123; Function&lt;Integer, Integer&gt; add2 = x -&gt; x + 2; Function&lt;Integer, Integer&gt; mult3 = x -&gt; x * 3; Function&lt;Integer, Integer&gt; mult3add2 = add2.compose(mult3); Function&lt;Integer, Integer&gt; add2mult3 = add2.andThen(mult3); System.out.println(\"mult3add2(1): \" + mult3add2.apply(1)); System.out.println(\"add2mult3(1): \" + add2mult3.apply(1)); &#125; //Consumer 接口定义的复合方法 @Test public void testConsumer() &#123; Logger log = Logger.getLogger(\"\"); Consumer&lt;String&gt; printer = System.out::println; Consumer&lt;String&gt; logger = log::info; Consumer&lt;String&gt; printThenLog = printer.andThen(logger); Stream.of(\"this\", \"is\", \"a\", \"stream\", \"of\", \"strings\").forEach(printThenLog); &#125; //Predicate 接口定义的复合方法 @Test public void testPredicate() &#123; Predicate&lt;String&gt; p = s -&gt; s != null; Predicate&lt;String&gt; p2 = p.and(s -&gt; s.length() &gt; 0); String s = \"\"; System.out.println(p2.test(s)); &#125; @Test public void testOptional() &#123; Optional optional = Optional.ofNullable(null); System.out.println(optional.orElseGet(() -&gt; Integer.parseInt(\"10000\"))); Optional&lt;String&gt; firstEven = Stream.of(\"five\", \"even\", \"length\", \"string\", \"values\") .filter(s -&gt; s.length() % 2 == 0) .findFirst(); System.out.println(firstEven.orElse(\"null\")); &#125; @Test public void testIO() &#123; try (Stream&lt;String&gt; lines = Files.lines(Paths.get(\"/usr/share/dict/web2\"))) &#123; lines.filter(s -&gt; s.length() &gt; 20) .sorted(Comparator.comparingInt(String::length).reversed()) .limit(10) .forEach(w -&gt; System.out.printf(\"%s (%d)%n\", w, w.length())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testLettersNumIO() &#123; try (Stream&lt;String&gt; lines = Files.lines(Paths.get(\"/usr/share/dict/web2\"))) &#123; lines.filter(s -&gt; s.length() &gt; 20) .collect(Collectors.groupingBy(String::length, Collectors.counting())) .forEach((len, num) -&gt; System.out.println(len + \": \" + num)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testLettersNumOrder() &#123; try (Stream&lt;String&gt; lines = Files.lines(Paths.get(\"/usr/share/dict/web2\"))) &#123; Map&lt;Integer, Long&gt; map = lines.filter(s -&gt; s.length() &gt; 20) .collect(Collectors.groupingBy(String::length, Collectors.counting())); map.entrySet().stream() .sorted(Map.Entry.comparingByKey(Comparator.reverseOrder())) .forEach(entry -&gt; System.out.println(entry.getKey() + \": \" + entry.getValue())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 文件系统的遍历 */ @Test public void testFileScan() &#123; try (Stream&lt;Path&gt; paths = Files.walk(Paths.get(\"src/main/java\"))) &#123; paths.forEach(System.out::println); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testFileFind() &#123; try (Stream&lt;Path&gt; paths = Files.find(Paths.get(\"src/main/java\"), Integer.MAX_VALUE, (path, attributes) -&gt; !attributes.isDirectory() &amp;&amp; path.toString().contains(\"Lambda\"))) &#123; paths.forEach(System.out::println); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testTimeNow() &#123; System.out.println(\"Instant.now(): \" + Instant.now()); System.out.println(\"LocalDate.now(): \" + LocalDate.now()); System.out.println(\"LocalTime.now(): \" + LocalTime.now()); System.out.println(\"LocalDateTime.now(): \" + LocalDateTime.now()); System.out.println(\"ZonedDateTime.now(): \" + ZonedDateTime.now()); &#125; @Test public void testTimeOf() &#123; System.out.println(\"First landing on the Moon:\"); LocalDate moonLandingDate = LocalDate.of(1969, Month.JULY, 20); LocalTime moonLandingTime = LocalTime.of(20, 18); System.out.println(\"Date: \" + moonLandingDate); System.out.println(\"Time: \" + moonLandingTime); System.out.println(\"Neil Armstrong steps onto the surface: \"); LocalTime walkTime = LocalTime.of(20, 2, 56, 150_000_000); LocalDateTime walk = LocalDateTime.of(moonLandingDate, walkTime); System.out.println(walk); &#125; @Test public void convertDateToLocalDate() &#123; LocalDate localDate = convertFromUtilDateUsingInstant(new Date()); System.out.println(localDate); &#125; public LocalDate convertFromUtilDateUsingInstant(Date date) &#123; return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate(); &#125; public LocalDateTime convertFromCalendarUsingGetters(Calendar cal) &#123; return LocalDateTime.of(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH), cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.HOUR), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND)); &#125; @Test public void testTiming() &#123; Instant start = Instant.now(); // 调用需要计时的方法 List&lt;Integer&gt; list = Lists.newArrayList(); for (int i = 0; i &lt; 1024000; i++) &#123; list.add(Integer.valueOf(i)); if (i % 10 == 0) &#123; System.gc(); &#125; &#125; Instant end = Instant.now(); System.out.println(getTiming(start, end) + \" seconds\"); &#125; public static double getTiming(Instant start, Instant end) &#123; return Duration.between(start, end).toMillis() / 1000.0; &#125; @Test public void testList() &#123; Lists.newArrayList(); &#125; @Test public void testTreeMap() &#123; //List&lt;Integer&gt; numbers = IntStream.range(-10, 10).boxed().collect(toList()); List&lt;Integer&gt; numbers = Lists.newArrayList(-10, -9, -8, -7, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, -5, 8, -6, 9); System.out.println(numbers); Map&lt;Integer, Integer&gt; map = Maps.newTreeMap(Comparator.&lt;Integer&gt;reverseOrder()); for (Integer i : numbers) &#123; map.put(i, i); &#125; map.forEach((k, v)-&gt; System.out.printf(\"%d, %d\\n\",k,v)); System.out.println(); &#125; @Test public void testTreeMap2() &#123; //List&lt;Integer&gt; numbers = IntStream.of(3, 1, 4, 1, -1, -3, 9).boxed().collect(toList()); //List&lt;Integer&gt; numbers = new Random().ints().limit(10).boxed().collect(toList()); List&lt;Integer&gt; numbers = Lists.newArrayList(1033293453, 1688703861, -1397662954, 1358394462, 2144737669, 1683364491, 906680402, 2094148244, 898301002, 134828019); System.out.println(numbers); //TreeMap&lt;Integer, Integer&gt; map = Maps.newTreeMap(Comparator.&lt;Integer&gt;reverseOrder()); // 正确写法 //TreeMap&lt;Integer, Integer&gt; map = Maps.newTreeMap((o1, o2) -&gt; o2 - o1);//错误, TreeMap&lt;Integer, Integer&gt; map = Maps.newTreeMap((o1, o2) -&gt; o2.compareTo(o1)); for (Integer i : numbers) &#123; map.put(i, i); &#125; map.forEach((k, v)-&gt; System.out.printf(\"%d, %d\\n\",k,v)); System.out.println(); &#125;@Testpublic void testParallelStream() &#123; List&lt;Long&gt; list = LongStream.range(0, 10000).boxed().collect(Collectors.toList()); Stopwatch stopwatch = Stopwatch.createStarted(); logger.info(\"start\"); Lists.partition(list, 2000).parallelStream().forEach(l -&gt; &#123; try &#123; Thread.sleep(100L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long end1 = stopwatch.elapsed(TimeUnit.MILLISECONDS); logger.info(\"end:&#123;&#125;\", end1); Lists.partition(list, 2000).stream().forEach(l -&gt; &#123; try &#123; Thread.sleep(100L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long end2 = stopwatch.elapsed(TimeUnit.MILLISECONDS); logger.info(\"end:&#123;&#125;\", end2 - end1);&#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/categories/Java/"}]},{"title":"English单词本","slug":"English单词本","date":"2019-09-26T00:15:07.755Z","updated":"2020-11-09T09:19:53.203Z","comments":true,"path":"2019/09/26/English单词本/","link":"","permalink":"https://www.iteway.com/2019/09/26/English单词本/","excerpt":"记录一些单词","text":"记录一些单词 predicate123n. 谓语，述语adj. 谓语的，述语的v. 使……基于, 断言, 暗示 月份英文1234567891011121314151617181920212223一月bai Jan. January二月 Feb. February三月 Mar. March四月 Apr. April五月 May. May六月 Jun. June七月 Jul. July八月du Aug. August九月 Sept. September十月 Oct. October十一月 Nov. November十二月 Dec. December","categories":[{"name":"English","slug":"English","permalink":"https://www.iteway.com/categories/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://www.iteway.com/tags/English/"}],"keywords":[{"name":"English","slug":"English","permalink":"https://www.iteway.com/categories/English/"}]},{"title":"Java正则表达式","slug":"Java正则表达式","date":"2018-01-30T09:58:12.000Z","updated":"2018-01-30T09:58:12.000Z","comments":true,"path":"2018/01/30/Java正则表达式/","link":"","permalink":"https://www.iteway.com/2018/01/30/Java正则表达式/","excerpt":"上一篇我们介绍了正则表达式,本文我们细数Java中的正则表达式应用,主要介绍在String中和Pattern与Matcher的用法","text":"上一篇我们介绍了正则表达式,本文我们细数Java中的正则表达式应用,主要介绍在String中和Pattern与Matcher的用法 String中的正则表达式matchespublic boolean matches(String regex)匹配某正则表达式:返回boolean类型值 例如:123456//一段文字String text = \"[2018-01-20] this is a text,,,and hello world,hello everyone,\";boolean bool = text.matches(\"^\\\\[20\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d\\\\].*\");//true replaceFirstpublic String replaceFirst(String regex, String replacement)替换第一个符合正则的值 替换为replacement 例如:替换第一个llo结尾的单词 123456//一段文字String text = \"[2018-01-20] this is a text,,,and hello world,hello everyone,\"; String result = text.replaceFirst(\"\\\\w+llo\",\"world\"); //[2018-01-20] this is a text,,,and world world,hello everyone, replaceAllpublic String replaceAll(String regex, String replacement)替换第所有符合正则的值 替换为replacement 1234567//一段文字String text = \"[2018-01-20] this is a text,,,and hello world,hello everyone,\";result = text.replaceAll(\"\\\\w+llo\", \"world\");//[2018-01-20] this is a text,,,and world world,world everyone, splitpublic String[] split(String regex)根据给定正则表达式的匹配拆分此字符串,它是全部拆分,最后一个值如果是被拆分的字符串,则不计入,第一个如果是被拆分的字符串,则记为一个&quot;&quot;空字符串,中间的如果是几个被分隔的字符串,则记为&quot;&quot;空字符串 例如:按照,拆分 1234567891011121314151617String text = \",[2018-01-20] this is a text,,,and hello world,hello everyone,\";String[] arr = text.split(\",\", 2);System.out.println(arr.length);for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125;/**6[2018-01-20] this is a textand hello worldhello everyone**/ public String[] split(String regex, int limit)根据匹配给定的正则表达式来拆分此字符串,limit 是限制拆分的次数,实际分解的次数是 limit-1 次,limit 就是分解后数组的 length。 123456789101112String text = \",[2018-01-20] this is a text,,,and hello world,hello everyone,\";String[] arr = text.split(\",\", 2);System.out.println(arr.length);for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125;/**2[2018-01-20] this is a text,,,and hello world,hello everyone,**/ 注意replace方法public String replace(CharSequence target, CharSequence replacement)target的值是要替换的值,而不是正则表达式,所以与上面有区别.所有target会被替换为replacement 例如:替换text中的hello1234567//一段文字String text = \"[2018-01-20] this is a text,,,and hello world,hello everyone,\";result = text.replace(\"hello\", \"world\");System.out.println(\"replace() \"+ result);//[2018-01-20] this is a text,,,and world world,world everyone, Pattern 和 MatcherPatternMatcherPattern 和 Matcher例子需求将文件夹里面的数据转为json串样式:形如: 文件夹里数据:00望远镜（形） 结果数据:{id:00, title:&quot;00 望远镜&quot;, desc:&quot;形&quot;, cardUrl:&quot;https://www.iteway.com/uploads/super_memory/00.jpg&quot;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.Map;import java.util.TreeMap;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * @author zhaomingwei * Created on 18/1/17. */public class FormatStr &#123; private static final Pattern PATTERN = Pattern.compile(\"(\\\\d+)([\\\\u4e00-\\\\u9fa5]+)(（)([\\\\u4e00-\\\\u9fa5]+)(）)\"); public static void main(String[] args) throws IOException &#123; BufferedReader reader = new BufferedReader(new FileReader(new File(\"/Users/zhaomingwei/Downloads/number\"))); TreeMap&lt;Integer,NumberEncode&gt; treeMap = new TreeMap(); String line; while ((line=reader.readLine()) !=null)&#123; //System.out.println(line); Matcher matcher = PATTERN.matcher(line); while (matcher.find())&#123; treeMap.put(Integer.parseInt(matcher.group(1)), new NumberEncode(matcher.group(1), matcher.group(1)+\" \"+matcher.group(2), matcher.group(4), \"https://www.iteway.com/uploads/super_memory/\"+ matcher.group(1)+\".jpg\" )); &#125; &#125; for (Map.Entry&lt;Integer,NumberEncode&gt; entry: treeMap.entrySet())&#123; System.out.print(entry.getValue()); System.out.println(\",\"); &#125; &#125;&#125;class NumberEncode&#123; private String id; private String title; private String desc; private String cardUrl; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125; public String getCardUrl() &#123; return cardUrl; &#125; public void setCardUrl(String cardUrl) &#123; this.cardUrl = cardUrl; &#125; public NumberEncode(String id, String title, String desc, String cardUrl) &#123; this.id = id; this.title = title; this.desc = desc; this.cardUrl = cardUrl; &#125; @Override public String toString() &#123; return \"&#123;\" + \"id:\" + id + \", title:\\\"\" + title + '\\\"' + \", desc:\\\"\" + desc + '\\\"' + \", cardUrl:\\\"\" + cardUrl + '\\\"' + '&#125;'; &#125;&#125; function ishidden(odiv){ var vdiv = document.getElementById(odiv); vdiv.style.display = (vdiv.style.display == 'none')?'block':'none'; } #点击此处展开文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 01冷饮（音）11筷子（形）21鳄鱼（音）31鲨鱼（音）41蜥蜴（音）51劳动者（意）02铃儿（音）12婴儿（音）22鸳鸯（形）32扇儿（音）42柿儿（音）52鼓儿（音）03三脚（形）13医生（音）23耳塞（音）33闪闪的钻石(音)43石山（音）53火山（音）04零食（音）14钥匙（音）24闹钟(24小时)34三丝巾（音）44蛇（嘶嘶声）54武士（音）05礼物（蛋糕）15鹦鹉（音）25二胡（音）35山虎（音）45师傅（音）55火车(呜呜声)06手枪（形）16石榴（音）26二流子（音）36山鹿（音）46饲料（音）56蜗牛（音）07令旗（音）17仪器（音）27耳机（音）37山鸡（音）47司机（音）57武器（音）08溜冰鞋（形）18腰包（音）28恶霸（音）38妇女（意）48石板（音）58尾巴（音）09猫（意）19药酒（音）29二舅（音）39三九胃态（音）49湿狗（音）59五角星（音）10棒球（形）20鹅蛋（形）30三轮车（音）40司令（音）50武林（音）60榴莲（音）61儿童（节日）71机翼（音）81白蚁（音）91球衣（音）0呼啦圈（形）62牛儿（音）72企鹅（音）82靶儿（音）92球儿（音）1树（形）63流沙（音）73花旗参（音）83爬山（音）93旧伞（音）2鹅（形）64律师（音）74骑士（音）84巴士（音）94旧（首）饰3耳朵（形）65尿壶（音）75西服（音）85宝物（音）95酒壶（音）4红旗（形）66蝌蚪（形）76汽油（音）86八路（音）96旧炉（音）5钩子（形）67油漆（音）77机器人（音）87白旗（音）97旧旗（音）6勺子（形）68喇叭（音）78青蛙（音）88爸爸（音）98酒吧（音）7锄头（形）69料酒（音）79汽球（音）89芭蕉（音）99舅舅（音）8葫芦（形）70冰淇凌（音）80巴黎:铁塔（音）90酒瓶（音）00望远镜（形）9口哨（形）","categories":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/tags/Java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.iteway.com/tags/正则表达式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/categories/Java/"}]},{"title":"Java对象和类简介","slug":"Java对象和类简介","date":"2018-01-30T09:57:16.000Z","updated":"2018-01-30T09:57:16.000Z","comments":true,"path":"2018/01/30/Java对象和类简介/","link":"","permalink":"https://www.iteway.com/2018/01/30/Java对象和类简介/","excerpt":"Java是一种面向对象的语言，独立于平台的安全语言，它比C++更容易学习，而且更能避免被误用，能开发出许多大型的项目来：比如Hadoop 生态系统","text":"Java是一种面向对象的语言，独立于平台的安全语言，它比C++更容易学习，而且更能避免被误用，能开发出许多大型的项目来：比如Hadoop 生态系统 一、声明 : It is time to forge ahead.Java是一种面向对象的语言，独立于平台的安全语言，它比C++更容易学习，而且更能避免被误用，能开发出许多大型的项目来：比如Hadoop 生态系统，优点： 1.Java自动负责内存的分配和释放 2.Java没有指针 3.Java只具备面向对象编程中的单继承， 4.Java之所以安全两个关键的因素是没有指针，且能自动管理内存 二、对象和类先从对象和类讲起吧，因为基本的语法之类，总是要为对象和类的内部只用，不能脱离对象和类而存在。 类class：是用来创建对象的模板 对象：则是类创建出来的，但是从物理角度分析：万物皆对象（Object），也即是一切都是东西 是东西的话就得有前因后果（继承），有结构属性，这方面的设计是挺符合人类的习惯的，怪不得那么多人去学习Java呢 对象的类属性： 属性：是区别于其他对象的数据，可用于确定属于该类的对象的外观，状态和其他性质； 属性是从国变量定义的，变量是计算机存放信息的位置； 实例变量；定义特定对象的属性；也叫做成员变量 成员方法：是定义一个对象的类行为 创建类：class 类名用Java语法定义人类：public class Person{成员变量；成员方法；} 例如：定义一个人类的对象类： 人类，有属性：头，身体，手，脚head、body、hand、foot 有构造函数：即人生来就有的初始化自己 public Person(){} 成员方法: 也就是人所居右的行为: 比如:吃eat ,跑 run 等等 具体实现如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package action;public class Person &#123; //成员变量 String head; String body; String hand; String foot; //构造方法 //1.无参构造器: public Person() &#123; super(); //生来不作为^_^,仅从父类获得构造 &#125; //2.有参构造器 public Person(String head, String body, String hand, String foot) &#123; super(); //初始化成员变量 this.head = head; this.body = body; this.hand = hand; this.foot = foot; &#125; //成员方法 public int run()&#123; //动作,跑了1000米 return 1000; &#125; public void eat(int food)&#123; //吃饭,越吃饭越少 food--; &#125; //成员变量的赋值与取值操作 public String getHead() &#123; return head; &#125; public void setHead(String head) &#123; this.head = head; &#125; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getHand() &#123; return hand; &#125; public void setHand(String hand) &#123; this.hand = hand; &#125; public String getFoot() &#123; return foot; &#125; public void setFoot(String foot) &#123; this.foot = foot; &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://www.iteway.com/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/tags/Java/"},{"name":"Java面向对象","slug":"Java面向对象","permalink":"https://www.iteway.com/tags/Java面向对象/"},{"name":"Java类","slug":"Java类","permalink":"https://www.iteway.com/tags/Java类/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://www.iteway.com/categories/Java基础/"}]},{"title":"Java变量、基本数据类型及其对应的包装类型","slug":"Java变量、基本数据类型及其对应的包装类型","date":"2018-01-19T08:52:18.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/19/Java变量、基本数据类型及其对应的包装类型/","link":"","permalink":"https://www.iteway.com/2018/01/19/Java变量、基本数据类型及其对应的包装类型/","excerpt":"本文主要讲解Java变量、基本数据类型及其对应的包装类型基础细节知识","text":"本文主要讲解Java变量、基本数据类型及其对应的包装类型基础细节知识 一、变量Java变量的定义任何的语言必须要的恐怕是变量了在Java中变量是十分的容易上手，于C、C++语言类似，Java的变量声明：数据类型 变量名；//分号是必须的变量名命名规则:包括 英文,数字, _ ,$ ,而且不能以数字开头; 变量的定义举个栗子: 12345int a;int _b;int $c;int 3a;//编译错误int &amp;c;//编译错误 编译错误是指,在程序运行前,编译器对程序做的一些基本语法的检查错误; 另外要注意的一点: 没有初始化的局部变量不能直接使用,如: 12int a;System.out.println(a); //编译错误 如果作为成员变量出现,即这个变量是属于某个类所有,而不属于某个方法函数所有的变量,可以不初始化,其默认的值为对应的0,或者是null; 二、基本数据类型基本数据类型:如图基本数据类型如上图的八种: 字面量：如 1int a = 3； //3就是字面量,或者称作直接量 使用的时候主要注意的有以下几点： 1、基本类型字面量默认类型整形类型的字面量默认为int,所以在初始化或者赋值的时候不能超过int的最大值,如果超过;则编译错误, 如下面就是编译错误: 1int a = 1000000000000; 所以当:数值较大的时候要使用long 类型; 1long a = 1000000000000L;//加个L代表是long 类型 同时double和float也有这样的问题,带小数点的字面量的数据类型为double 12float c = 1.222222222222222222;//编译错误double d = 1.222222222222222222; 正确如下写法,float类型的值明确带个f或者F: 12float i = 1.02f;double j = 1.02; 2、另外在做运算的时候,要注意不同类型的转换问题转换如图所示: 排在最右端的是大类型，也就是当把小类型的字面量赋给大类型字面量的时候，会发生类型自动向大类型转化,但是大类型不能直接向小类型转化,需要强制转化如： 123double i = 2；//此时的 i 为double int j = i; //编译错误;此时的i为double大类型 不能直接转化为小类型;int j = (int)i; 但是 如果double有小数点的话,强制转化会造成小数点的损失精度,如: 123double i = 2.6;int j = (int)i;System.out.println(j); //结果是2,并不会四舍五入 如果强转为小类型的数据类型的范围较大,会出现异常.如:int i = (int)10000000000000000000000;错误,所以要根据数据类型的具体情况而. 3、变量的作用域Java语言支持的变量类型有： 成员变量 局部变量 其实变量的这些分类就如下图一样明了, class 中定义的变量 而不属于其他任何方法的变量,叫做成员变量. 属于某个方法的变量叫做局部变量 4、 变量作用域和生命周期 作用域: 成员变量的作用域比较大,站得高看得远,这个类的所有的方法都能够”看到它”,都能去用它局部变量作用域:只在它所在的方法中被使用,其他方法”看不到”这个变量,但是也可以与成员变量同名,但是这个时候成员变量的调用就不能直接调用了要用到this,this说明是这个类的东西. 生命周期: 明显的:成员变量的生命周期和整个类的生命周期是一致的,就是这个类 活到什么时候,这个成员变量就活到什么时候.局部变量的生命周期和它所在方法的生命周期一致,调用这个方法结束后,这个局部变量就被销毁了. 练一练: 这就像”男人(女人)和 人 分不开,人 和 运动 分不开”一样 ,数据类型 和 变量 是分不开的,变量 和 运算符 也是分不开的.像人天生为分为男女一样,一个变量在声明的时候也要先说明数据类型. 1234567891011121314151617//类的声明一定要大写,而且要与文件同名 public class MyProgram &#123; char x = 0; public void main(String[] args) &#123; //java的输出函数 System.out.println() //数据类型 和 变量 是分不开的,变量 和 运算符 也是分不开的 //这就像\"男人(女人)和 人 分不开,人 和 运动 分不开\" //像人天生为分为男女一样,一个变量在声明的时候也要先说明数据类型 int a, b, c; // 声明三个int型整数：a、 b、c。 int d = 3, e, f = 5; // d声明三个整数并赋予初值。 byte z = 22; // 声明并初始化z。 double pi = 3.14159; // 声明了pi。 char x = 'x'; // 变量x的值是字符'x'。 可以与成员变量重名, x = this.x; //用this可以调用到成员变量 System.out.println(x); //输出将是0; &#125;&#125; 三、包装类型基本数据类型对应的包装类型基本数据类型:byte,int,short, long,boolean,char,float,double包装类型: Byte,Integer,Short,Long,Boolean,Character,Float,Double 自动拆包装包包装数据类型不仅仅看上去是把首字母大写了,而且还有了一个本质的变化,那就是摇身一变,变成了引用类型随着JDK的升级,包装类有了自动拆包(包装类型变成对应的基本类型),装包(基本类型变成对应的包装类型):例如: 1234567Integer i = new Integer(1);//初始化System.out.println(i.getClass());//class java.lang.Integerint j = 0;i = Integer.valueOf(j);//这就是所谓的装包但是可以直接写成, i = j;int a = i.intValue(); //这就是所谓的拆包,也可以直接写作,int a = iSystem.out.println(i);//此处进行了自动拆包String与基本数据类型的转化,可以参考第六节 四、运算符算数运算符在发例子之前先了解一下运算符和优先级,其实里面大部分大家都认识了; 特别注意的是++和--,++或-- 在变量前,先做自增或自减操作,再用,在变量后面的话,先用变量,然后做自增或自减操作例如: 12345int B = 20;int x = ++B;int y = B++;//结果x = 21;y=21; 但B最终都是发生变化的,B = 22; 关系运算符: Java运算符优先级当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。 例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。 再如，x = 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。 下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://www.iteway.com/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/tags/Java/"},{"name":"Java基本数据类型","slug":"Java基本数据类型","permalink":"https://www.iteway.com/tags/Java基本数据类型/"},{"name":"Java包装类型","slug":"Java包装类型","permalink":"https://www.iteway.com/tags/Java包装类型/"}],"keywords":[{"name":"Java基础","slug":"Java基础","permalink":"https://www.iteway.com/categories/Java基础/"}]},{"title":"Markdown语法和MWeb写作使用说明","slug":"Markdown语法和MWeb写作使用说明","date":"2018-01-19T08:52:18.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/19/Markdown语法和MWeb写作使用说明/","link":"","permalink":"https://www.iteway.com/2018/01/19/Markdown语法和MWeb写作使用说明/","excerpt":"Markdown语法和MWeb写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。","text":"Markdown语法和MWeb写作使用说明Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 强调Markdown 语法： 12345*这些文字会生成`&lt;em&gt;`*_这些文字会生成`&lt;u&gt;`_**这些文字会生成`&lt;strong&gt;`**__这些文字会生成`&lt;strong&gt;`__ 在 MWeb 中的快捷键为： CMD + U、CMD + I、CMD + B效果如下： 这些文字会生成&lt;em&gt;这些文字会生成&lt;u&gt; 这些文字会生成&lt;strong&gt;这些文字会生成&lt;strong&gt; 换行四个及以上空格加回车。如果不想打这么多空格，只要回车就为换行，请勾选：Preferences - Themes - Translate newlines to &lt;br&gt; tags 列表无序列表Markdown 语法： 1234* 项目一 无序列表 `* + 空格键`* 项目二 * 项目二的子项目一 无序列表 `TAB + * + 空格键` * 项目二的子项目二 在 MWeb 中的快捷键为： Option + U效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： 123451. 项目一 有序列表 `数字 + . + 空格键`2. 项目二 3. 项目三 1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键` 2. 项目三的子项目二 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 列表中嵌入代码块语法1. 项目一 有序列表 `数字 + . + 空格键` 列表中嵌入代码块必须前后空一行，如这个写法 12345function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 其他文本。 2. 项目二 任务列表（Task lists）Markdown 语法： 12- [ ] 任务一 未做任务 `- + 空格 + [ ]`- [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下： 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： 12![GitHub set up](https://www.iteway.com/uploads/fileImages/set-up-git.gif)格式: ![Alt Text](url) Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如为 ![GitHub-w140](set-up-git.gif)： 链接Markdown 语法： 123email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#64;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： 123某某说:&gt; 第一行引用&gt; 第二行费用文字 CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用第二行费用文字 行内代码Markdown 语法： 1像这样即可：`&lt;addr&gt;` `code` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&lt;addr&gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; CMD + Shift + K 可插入Markdown语法。效果如下： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:'#foo'&#125;) &#125;&#125; 顺序图或流程图Markdown 语法： sequence123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 flow1234567st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 效果如下（ Preferences - Themes - Enable sequence &amp; flow chart 才会看到效果 ）： 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： 1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： ~~删除这些~~ 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： *** ***** - - - 效果如下： MathJaxMarkdown 语法： 12345678块级公式：$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$\\\\[ \\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125; \\\\]行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ \\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\] 行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 脚注（Footnote）Markdown 语法： 1这是一个脚注：[^sample_footnote] 效果如下： 这是一个脚注：^sample_footnote 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： 1[TOC] 效果如下： [TOC] 标题Markdown 语法： 123# 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ###### 第六级标题 `&lt;h6&gt;` 效果如下： 第一级标题 &lt;h1&gt;第二级标题 &lt;h2&gt;第六级标题 &lt;h6&gt;转载自: Markdown 语法和 MWeb 写作使用说明参考文章: 分享hexo时序图和流程图插件参考: 时序图github st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);张三->李四: 嘿，小四儿, 写博客了没? Note right of 李四: 李四愣了一下，说： 李四-->张三: 忙得吐血，哪有时间写。{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"markdown","slug":"markdown","permalink":"https://www.iteway.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.iteway.com/tags/markdown/"},{"name":"mweb","slug":"mweb","permalink":"https://www.iteway.com/tags/mweb/"}],"keywords":[{"name":"markdown","slug":"markdown","permalink":"https://www.iteway.com/categories/markdown/"}]},{"title":"postgresql入门详细总结","slug":"postgresql入门详细总结","date":"2018-01-19T08:52:18.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/19/postgresql入门详细总结/","link":"","permalink":"https://www.iteway.com/2018/01/19/postgresql入门详细总结/","excerpt":"本文介绍postgresql的部分基本数据类型和基本操作,包括时间类型,字符串操作,数组操作等","text":"本文介绍postgresql的部分基本数据类型和基本操作,包括时间类型,字符串操作,数组操作等 postgresql下载地址:https://www.postgresql.org/download/ 一、字符串操作lpad字符和字符串lpad(要补齐的字符串,总长度,补上的字符串) 123select lpad('ab',4,'0') as ab_lpad, rpad('ab',4,'0') as ab_rpad, lpad('abcde',4,'0') as ab_lpad_trunc; split_partpostgresql分隔字符串,split_part语法:split_part(string text, delimiter text, column integer) 12select split_part('abc.123.z45', '.', 2); select split_part('abc_123_z45', '_', 2); string_to_array(text, text)string_to_array(text, text)可以将一个字符串 拆分成为一个数组 1select a[1] from string_to_array('abc_123_z45', '_') as a; 将字符串展开为若干记录&quot;unnest&quot;(anyarray) string_to_array 和 unnest结合使用, 可以将字符串展开为若干记录 1select a[1] from string_to_array('abc_123_z45', '_') as a; 二、postgresql正则表达式和模式匹配模式匹配 \\1 和 \\2是模式匹配表达式中的元素. \\( 是特殊字符 ( 的转义 1234select regexp_replace('6197306254','([0-9]&#123;3&#125;)([0-9]&#123;3&#125;)([0-9]&#123;4&#125;)',E'\\(\\\\1) \\\\2-\\\\3') as x;` 将文本中的电话号码作为单独的行返回 123select unnest(regexp_matches('Cell (619)852-5083. Casa 619-730-6254. Besame mucho.', E'[(]&#123;0,1&#125;[0-9]&#123;3&#125;[)-.]&#123;0,1&#125;[0-9]&#123;3&#125;[-.]&#123;0,1&#125;[0-9]&#123;4&#125;','g') ) as x; ~ 运算符除了正则表达式专用的那些函数外,正则表达式还和 ~ 运算符 一起使用, 如下:查出所有内嵌了电话号码的字符串 12select description from mytablewhere description ~ E'[(]&#123;0,1&#125;[0-9]&#123;3&#125;[)-.]&#123;0,1&#125;[0-9]&#123;3&#125;[-.]&#123;0,1&#125;[0-9]&#123;4&#125;'; 三、postgresql时间类型 最先进的,最全的时间类型 时间加减法：一个小时前 1select current_timestamp - interval '1 hour'; 提取当前小时 1select extract(hour from current_timestamp); 获取当前时间戳 12345select current_timestamp; select now()::timestamp(0)without time zone;select to_timestamp(to_char(current_timestamp,'yyyy-mm-dd hh24'),'yyyy-mm-dd hh24');#获取部分时：hourselect EXTRACT(HOUR FROM current_timestamp) - 1; 1. date该类型仅存储 月,日,年,没有失去 , 小时 , 分 和 秒 的信息 2. time 该类型仅存储 小时,分,秒 信息, 不带日期 和 时区信息 3. timestamp 该数据类型存储了日期(年月日) 和 时间(时分秒) 4. timestamptz 存储了日期 和 时间 以及时区 5. timetz携带了时区信息 没有日期信息 6. interval该类型描述了时间段的长度,单位可以是小时,天, 月, 分钟, 或者 其他粒度.该类型适用于数学运算场景 7. tsrange 开区间闭区间限定符,定义了一个 从14:00 开始 到 15:00之前结束的一个时间段 timestamp 1select '[2012-01-01 14:00 2012-01-01 15:00)'::tsrange; 8. tstzrange定义 timestamptz 的开区间和闭区间 9. daterange 定义日期的开区间和闭区间 12select '2016-05-26 3:43:00 PM'::timestamp - interval '1 hour'; select '2016-05-26 15:43:00'::timestamp - interval '1 hour'; 重叠运算 对时间戳和日期类型:使用 OVERLAPS overlaps 时间区域重叠运算符 1234select ('2012-10-25 10:00 AM'::timestamp ,'2012-10-25 2:00 PM'::timestamp) overlaps ('2012-10-25 11:00 AM'::timestamp ,'2012-10-25 2:00 PM'::timestamp) as x,('2012-10-25'::date ,'2012-10-26'::date) overlaps ('2012-10-26'::date ,'2012-10-27'::date) as y;` 生成整数序列使用可选的步长形参,来生成整数序列 123456789select x from generate_series(1,51,13) as x;``` ## `generate_series` `generate_series` 用 `interval` 作为步长生成时间序列数组```sqlselect (dt - interval '1 day')::date as eom from generate_series('2012-02-01','2012-06-30',interval '1 month') as dt; 抽取时间类型的一部分date_part 或者 to_char 从日期类型和时间类型的数据值中抽取一部分 12select dt, date_part('hour',dt) as mh,to_char(dt,'HH12:MI:AM') as tmfrom generate_series('2012-03-11 12:30 AM','2012-03-11 3:00 AM',interval '15 minutes') as dt; generate_series 函数默认生成的是 timestamptz 类型数据,需要显示转换为timestamp类型 更多时间计算问题请见:PostgreSQL的时间/日期函数使用 四 数组类型1.数组构造函数array(子查询,或者 数组) 1234select array[2001,2002,2003] as yrs;select array(select distinct date_part('year',log_ts) from logs order_by date_part('year',log_ts)); 字符串数组转化为数组可以直接把一个字符串格式书写的数组转化为真正的数组,语法如下 1select '&#123;Alex,Sonia&#125;'::text[] as name, '&#123;43,40&#125;'::smallint[] as age; string_to_array(text, text)string_to_array(text, text) 将一个用固定分隔符分隔的字符串转化为数组 1select string_to_array('ca.ma.tx','.') as estados; array_aggarray_agg是一种变型聚合函数,它可以使用一组任何类型的数据并将其转换为数组 12select array_agg(log_ts order by log_ts) as x from logs where log_ts between '2011-01-01'::timestamptz and '2011-01-15'::timestamptz; 2.引用数组中的元素1select a[1] from string_to_array('abc_123_z45_12s_12_we', '_') as a; 3.数组拆分与连接第一个和第5个元素 a[1:5]12select a[1:5] from string_to_array('abc_123_z45_12s_12_we', '_') as a; select a[1:3] || a[4:5] from string_to_array('abc_123_z45_12s_12_we', '_') as a; 将数组元素展开为记录行 unnest1select unnest('&#123;xox,oxo,xox&#125;'::char(3)[]) as tic_tac_toe 你可以在一个 SELECT 语句中使用多个 unnest 函数，但如果每个 unnest 展开后的记录行数不一致，或者说“对不齐”，那么得到的最终结果将是这些结果集之间的笛卡儿积，看起来不太好理解。 123SELECTunnest('&#123;three,blind,mice&#125;'::text[]) As t,unnest('&#123;1,2,3&#125;'::smallint[]) As i; 如果你从上述一个数组中拿掉一个元素，那么两个数组的元素就无法对齐了，此时展开得到的结果如示例下 123SELECTunnest( '&#123;blind,mouse&#125;'::varchar[]) As v,unnest('&#123;1,2,3&#125;'::smallint[]) As i; 多实参 unnest 函数,只能在from 子句中出现使用多实参 unnest 取消不平衡数组的嵌套 1SELECT * FROM unnest('&#123;blind,mouse&#125;'::text[], '&#123;1,2,3&#125;'::int[]) As f(t,i); 五、区间类型1234select int4range(1,5) = '[1,4]'::int4range;select int4range(1,4) = '[1,4]'::int4range;select int4range(1,5) @&gt; '[1,4]'::int4range;select 4 &lt;@ '[1,4]'::int4range; 区间操作和集合操作123select '[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp;select '2011-01-10'::timestamp between '2011-01-01'::timestamp and '2011-01-10'::timestamp ; 离散区间int4range、int8range: 这是整数型离散区间，其定义符合前闭后开的规范化要求。 123select '[-2,2]'::int4range; --[-2,3)select 1 &lt;@ '[-2,2]'::int4range; --tselect 1.2 &lt;@ '[-2,2]'::int4range; --错误 错误: 操作符不存在: numeric &lt;@ int4range没有匹配指定名称和参数类型的操作符. 您也许需要增加明确的类型转换. numrange这是连续区间，可以用于描述小数、浮点数、或者双精度数字的区间。 12select '[-2,2]'::numrange; --[-2,2]select 1.2 &lt;@ '[-2,2]'::numrange; --t daterange这是不带时区信息的日期离散区间。 12select '[2011-01-01,2011-03-01)'::daterange --[2011-01-01,2011-03-01)SELECT daterange('2013-01-05','infinity','[]'); --[2013-01-05,infinity) tsrange、tstzrange 这是时间戳（日期加时间）类型的连续区间，秒值部分支持小数。tsrange 不带时区信息，tstzrange 带时区信息。 定义含区间类型字段的表时间类型区间是很常用的，假设你有一张 employment 表，表中存储了公司聘请雇员的历史记录。你可以像示例 5-20 那样用时间区间来定义一个员工在公司的服务年限，而不需要用起始时间和结束时间两个字段来表示。在本例中，我们给 period 列添加了一个索引以使用我们的区间列加速查询。 1234567CREATE TABLE employment (id serial PRIMARY KEY, employee varchar(20), period daterange);CREATE INDEX idx_employment_period ON employment USING gist (period); INSERT INTO employment (employee, period)VALUES ('Alex', '[2012-04-24, infinity)'::daterange), ('Sonia', '[2011-04-24,2012-06-01)'::daterange), ('Leo', '[2012-06-20, 2013-04-20)'::daterange), ('Regina', '[2012-06-20, 2013-04-20)'::daterange); 适用于区间类型的运算符 区间类型上用得最多的两个运算符是重叠运算符（&amp;&amp;）和包含运算符（@&gt;）。要了解区间运算符的完整列表，请参考 PostgreSQL 官方手册中的“区间类型运算符”一节 1. 重叠运算符顾名思义，重叠运算符 &amp;&amp; 的作用就是判定两个区间是否有重叠部分，如果有则返回 true，否则返回 false。 示例 ：查询谁与谁曾经同时在公司工作过 12345678910111213SELECT e1.employee, string_agg(DISTINCT e2.employee, ', ' ORDER BY e2.employee) AscolleaguesFROM employment As e1 INNER JOIN employment As e2ON e1.period &amp;&amp; e2.periodWHERE e1.employee &lt;&gt; e2.employeeGROUP BY e1.employee;-- employee | colleagues-- ---------+--------- Alex | Leo, Regina, Sonia-- Leo | Alex, Regina-- Regina | Alex, Leo-- Sonia | Alex 2. 包含与被包含关系运算符1234SELECT employee FROM employment WHERE period @&gt; CURRENT_DATE GROUP BY employee;-- employee-- ------ Alex 六、JSON数据类型JSON类型形如：{key:value} 123456789CREATE TABLE families_j (id serial PRIMARY KEY, profile json);INSERT INTO families_j (profile) VALUES ('&#123;\"name\":\"Gomez\", \"members\":[&#123;\"member\":&#123;\"relation\":\"padre\", \"name\":\"Alex\"&#125;&#125;,&#123;\"member\":&#123;\"relation\":\"madre\", \"name\":\"Sonia\"&#125;&#125;,&#123;\"member\":&#123;\"relation\":\"hijo\", \"name\":\"Brandon\"&#125;&#125;,&#123;\"member\":&#123;\"relation\":\"hija\", \"name\":\"Azaleah\"&#125;&#125;]&#125;'); json_extract_path、json_array_elements 以及 json_extract_path_text这三个函数来读取表中所有家庭成员的信息。 1234567SELECT json_extract_path_text(profile, 'name') As family, json_extract_path_text(json_array_elements( json_extract_path(profile,'members')), 'member','name' ) As member FROM families_j; select json_extract_path_text(json_array_elements(json_extract_path(profile,'members')),'member','name') from families_j; 运算符 -&gt;&gt; 和 #&gt;&gt; 是 json_extract_path_text 的简写。#&gt;&gt; 取用某个路径数组。 示例使用这些符号运算符对上面进行了重写。 输出JSON数据 12SELECT row_to_json(f) As xFROM (SELECT id, profile-&gt;&gt;'name' As name FROM families_j) As f; 七、构建自定义数据类型所有表都有一个对应的自定义数据类型 尽管仅仅通过建表就可以轻松创建复合数据类型，但有时候我们仍会需要从头开始构建自己的数据类型。例如，使用以下语句可以构建一个复杂数字数据类型： 1234CREATE TYPE complex_number AS (r double precision, i double precision);CREATE TABLE circuits (circuit_id serial PRIMARY KEY, ac_volt complex_number);SELECT circuit_id, (ac_volt).* FROM circuits;SELECT circuit_id, (ac_volt).r, (ac_volt).i FROM circuits; 为自定义数据类型构建运算符和函数创建运算符的第一步是创建其底层实现函数 示例 ：为 complex_number 创建底层实现函数 123456CREATE OR REPLACE FUNCTION add(complex_number, complex_number) RETURNS complex_number AS$$ SELECT ( (COALESCE(($1).r,0) + COALESCE(($2).r,0)), (COALESCE(($1).i,0) + COALESCE(($2).i,0)) )::complex_number;$$language sql; 接下来要创建一个运算符来代表此函数 示例：为 complex_number 类型定义 + 运算符 12345678CREATE OPERATOR +( PROCEDURE = add, LEFTARG = complex_number, RIGHTARG = complex_number,COMMUTATOR = +);-- 然后我们测试一下这个新的 + 运算符： SELECT (1,2)::complex_number + (3,-10)::complex_number; -- 输出结果是 (4,-8)。 虽然我们在此处没有举例说明，但你可以对函数和运算符进行重载， 以使其可以接受多种不同类型的输入。例如，你可以创建一个支持 complex_number 和 integer 相加的 add 函数和相应的 + 计算符，这就实现了对原逻辑的扩展。 支持自定义数据类型和运算符让 PostgreSQL 从机制上具有了自我演进的能力， 开源社区无数开发人员利用此能力为 PostgreSQL 平台添砖加瓦， 随着这个开发平台的羽翼日渐丰满，我们离“一切皆以表驱动”的理想境界也越来越近。 在 PostgreSQL 官方手册的“创建运算符”这一节中你可以看到系统允许使用哪些字符来定义新的运算符。参考官方手册中“运算符的优化信息”","categories":[{"name":"sql","slug":"sql","permalink":"https://www.iteway.com/categories/sql/"}],"tags":[{"name":"postgresql","slug":"postgresql","permalink":"https://www.iteway.com/tags/postgresql/"},{"name":"sql","slug":"sql","permalink":"https://www.iteway.com/tags/sql/"}],"keywords":[{"name":"sql","slug":"sql","permalink":"https://www.iteway.com/categories/sql/"}]},{"title":"一个node链表翻转的面试题","slug":"一个node链表翻转的面试题","date":"2018-01-19T08:52:18.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/19/一个node链表翻转的面试题/","link":"","permalink":"https://www.iteway.com/2018/01/19/一个node链表翻转的面试题/","excerpt":"经典面试题总结,欢迎大家来留言区讨论","text":"经典面试题总结,欢迎大家来留言区讨论 下面列举了两种解法:欢迎留言讨论一个node链表的值分别为67,0,24,58,31,请把node翻转 123456789101112131415161718192021public static class Node &#123; int val; Node next = null; Node(int val) &#123; this.val = val; &#125;&#125;public static void main(String[] args) &#123; Node nodeFirst = new Node(67); nodeFirst.next = new Node(0); nodeFirst.next.next = new Node(24); nodeFirst.next.next.next = new Node(58); nodeFirst.next.next.next.next = new Node(31); Node node = reverseNodeByNodeMethod(nodeFirst); while (node != null) &#123; System.out.println(node.val); node = node.next; &#125;&#125; 一种利用node自身的方法翻转. 1234567891011121314151617181920212223public static Node reverseNodeByNodeMethod(Node nodeFirst) &#123; Node currentNode = nodeFirst; Node nextNode = null; Node nextNextNode; Node newFirstNode = null; if (currentNode.next != null) &#123; nextNode = currentNode.next; &#125; currentNode.next = null; while (nextNode != null) &#123; if (nextNode.next != null) &#123; nextNextNode = nextNode.next; &#125; else &#123; newFirstNode = nextNode; nextNode.next = currentNode; break; &#125; nextNode.next = currentNode; currentNode = nextNode; nextNode = nextNextNode; &#125; return newFirstNode;&#125; 第二种解法,将node所有节点放入stack中,为了防止造成node内部循环,所以在stack存储之后将node.next置为null 1234567891011121314151617public static Node reverseNodeByStack(Node nodeFirst) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node node = nodeFirst; while (node.next != null) &#123; Node nextNode = node.next; stack.push(node); node.next = null; node = nextNode; &#125; Node newFirstNode = node; while (!stack.isEmpty()) &#123; node.next = stack.pop(); node = node.next; &#125; node.next = null; return newFirstNode;&#125;","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://www.iteway.com/categories/面试总结/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.iteway.com/tags/Java/"}],"keywords":[{"name":"面试总结","slug":"面试总结","permalink":"https://www.iteway.com/categories/面试总结/"}]},{"title":"一名3年工作经验的程序员应该具备的技能","slug":"一名3年工作经验的程序员应该具备的技能","date":"2018-01-19T08:52:18.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/19/一名3年工作经验的程序员应该具备的技能/","link":"","permalink":"https://www.iteway.com/2018/01/19/一名3年工作经验的程序员应该具备的技能/","excerpt":"面试感悟—-一名3年工作经验的程序员应该具备的技能原文地址http://www.cnblogs.com/xrq730/p/5260294.html，转载请注明出处，谢谢！","text":"面试感悟—-一名3年工作经验的程序员应该具备的技能原文地址http://www.cnblogs.com/xrq730/p/5260294.html，转载请注明出处，谢谢！ 前言因为和同事有约定再加上LZ自己也喜欢做完一件事之后进行总结，因此有了这篇文章。这篇文章大部分内容都是面向整个程序员群体的，当然因为LZ本身是做Java开发的，因此有一部分内容也是专门面向咱们Java程序员的。简单先说一下，LZ坐标杭州，13届本科毕业，算上年前在阿里巴巴B2B事业部的面试，一共有面试了有6家公司（因为LZ不想请假，因此只是每个晚上去其他公司面试，所以面试的公司比较少），其中成功的有4家，另外两家失败的原因在于： 阿里巴巴B2B事业部的面试，两轮技术面试都过了，最后一轮面试是对方的主管，由于听说技术面试过了基本上90%都面试成功了，所以LZ在和主管的交谈中也是毫无顾忌，说得天花乱坠，很多自己介于知道和不知道的东西都直接脱口而出了，结果多次被对方一反问就问得哑口无言。事后想来，模棱两可的答案是面试中最忌讳的，这次的失败也让LZ认真地对待后面的每一次面试 另外一家失败的是一家小公司，也就20来个人吧，整个团队是支付宝出来创业的，非常厉害。面试完LZ多方了解了一下，对方认为我基本功什么的都不错，但是实际项目经验还是欠缺一些，因为对方是创业型公司，需要人上手就能干活，因此我在这个时候还不是特别适合他们团队至于其他成功的四家公司，给LZ的面试评价都挺高的貌似，但LZ也不想记流水账，因此就不一一列举每家公司的面试过程了，下面LZ主要谈谈作为一名工作三年左右的Java程序员应该具备的一些技能以及个人的一些其他感悟。 关于程序员的几个阶段每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。LZ常常思考自己的未来，也从自己的思考中总结出了一些东西，作为第一部分来谈谈。LZ认为一名程序员应该有几个阶段（以下时间都算上实习期）： 第一阶段—-三年 我认为三年对于程序员来说是第一个门槛，这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段 第二阶段—-五年 五年又是区分程序员的第二个门槛。有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物 第三阶段—-十年 十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位，这对于自己绝对是一件荣耀的事，当然老板在经济上也绝不会亏待你 第一部分总结一下我认为，随着你工作年限的增长、对生活对生命认识的深入，应当不断思考三个问题： 我到底适不适合当一名程序员？ 我到底应不应该一辈子以程序员为职业？ 我对编程到底持有的是一种什么样的态度，是够用就好呢还是不断研究？ 最终，明确自己的职业规划，对自己的规划负责并为之努力。 关于项目经验LZ在网上经常看到一些别的朋友有提出项目经验的问题，依照LZ面试的感觉来说，面试主要看几点：项目经验+基本技术+个人潜力（也就是值不值得培养）。关于项目经验，我认为并发编程网的创始人方腾飞老师讲的一段话非常好：介绍产品时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？ 我觉得这就已经足以概括了。也许你仅仅工作一年，也许你做的是项目中微不足道的模块，当然这些一定是你的劣势且无法改变，但是如何弥补这个劣势，从方老师的话中我总结几点： 明确你的项目到底是做什么的，有哪些功能 明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用 明确你的模块在整个项目中所处的位置及作用 明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术 在你无法改变自己的工作年限、自己的不那么有说服力的项目经验的情况下（这一定是扣分项），可以通过这种方式来一定程度上地弥补并且增进面试官对你的好感度。 补充一点，在面试中聊你的项目的时候，有一个问题90%是绕不过的：谈一下你在项目中解决过的比较复杂的问题。这需要在工作中不断去发现和探索，不需要多，在你自己目前的项目中只要你找到一两个能说的问题就行。一个小技巧是，即使问题不是你解决的而是别人解决的，但是你把这个问题弄懂、搞透了，在面试的时候你一样可以把这个问题当作是你自己解决的来说—-毕竟，谁来管这个问题当时到底是不是你解决的呢？ 关于专业技能写完项目接着写写一名3年工作经验的Java程序员应该具备的技能，这可能是Java程序员们比较关心的内容。我这里要说明一下，以下列举的内容不是都要会的东西—-但是如果你掌握得越多，最终能得到的评价、拿到的薪水势必也越高。 1、基本语法这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。 最深入的一次，LZ记得面试官直接问到了我volatile关键字的底层实现原理（顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对公司的好感，LZ最终选择的就是问了这个问题的公司），不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度优先、广度次之为标准的，切记。 2、集合非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap，我给网友朋友们提供三点回答或者是研究方向：（1）ConcurrentHashMap的锁分段技术（2）ConcurrentHashMap的读是否要加锁，为什么（3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器 3、设计模式本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向：（1）你的项目中用到了哪些设计模式，如何使用（2）知道常用设计模式的优缺点（3）能画出常用设计模式的UML图 4、多线程这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同，总结起来是这么一个意思： 假如有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？ 聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。 另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。 最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。 synchronized和ReentrantLock的区别、synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等，关于多线程，我在之前有些过文章总结过多线程的40个问题，可以参看40个Java多线程问题总结。 5、IOIO分为File IO和Socket IO，File IO基本上是不会问的，问也问不出什么来，平时会用就好了，另外记得File IO都是阻塞IO。 Socket IO是比较重要的一块，要搞懂的是阻塞/非阻塞的区别、同步/异步的区别，借此理解阻塞IO、非阻塞IO、多路复用IO、异步IO这四种IO模型，Socket IO如何和这四种模型相关联。这是基本一些的，深入一些的话，就会问NIO的原理、NIO属于哪种IO模型、NIO的三大组成等等，这有些难，当时我也是研究了很久才搞懂NIO。提一句，NIO并不是严格意义上的非阻塞IO而应该属于多路复用IO，面试回答的时候要注意这个细节，讲到NIO会阻塞在Selector的select方法上会增加面试官对你的好感。 如果用过Netty，可能会问一些Netty的东西，毕竟这个框架基本属于当前最好的NIO框架了（Mina其实也不错，不过总体来说还是比不上Netty的），大多数互联网公司也都在用Netty。 6、JDK源码要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。LZ面试过程中被问了不少JDK源码的问题，其中最刁钻的一个问了LZ，String的hashCode()方法是怎么实现的，幸好LZ平时String源代码看得多，答了个大概。JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码：（1）List、Map、Set实现类的源代码（2）ReentrantLock、AQS的源代码（3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的（4）线程池的实现原理（5）Object类中的方法以及每个方法的作用这些其实要求蛮高的，LZ去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。 7、框架老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习框架的使用细节自然都不成问题。如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。LZ遇到的最变态的是让LZ画一下Spring的Bean工厂实现的UML图，当然面对这样一个有深度的问题，LZ是绝对答不出来的/(ㄒoㄒ)/~~ 8、数据库数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把SQL基础和SQL优化的内容准备一下。不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。 9、数据结构和算法分析数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和我聊到了数据库的索引，他问我：你知道索引使用的是哪种数据结构实现吗？LZ答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？LZ答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了显示LZ的博学，对算法分析也有一定的研究(⊙﹏⊙)b，LZ还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。 10、Java虚拟机出乎LZ的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，LZ去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践》，LZ就读了不下五遍。言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，LZ就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容： Java虚拟机的内存布局 GC算法及几种垃圾收集器 类加载机制，也就是双亲委派模型 Java内存模型 happens-before规则 volatile关键字使用规则也许面试无用，但在走向大牛的路上，不可不会。11、Web方面的一些问题Java主要面向Web端，因此Web的一些问题也是必问的。LZ碰到过问得最多的两个问题是：谈谈分布式Session的几种实现方式常用的四种能答出来自然是让面试官非常满意的，另外一个常问的问题是：讲一下Session和Cookie的区别和联系以及Session的实现原理这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。噢，想起来了，一致性Hash算法貌似也被问到了几次，这个LZ以前专门深入研究过并且写了两篇博文，因此问到这个问题LZ自然是答得毫不费力。文章是MemCache详细解读和对一致性Hash算法，Java代码实现的深入研究，特别说明，LZ真的不是在为自已以前写的文章打广告啊啊啊啊啊啊。最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。 关于HR面试如果你过五关斩六将，成功地通过了所有的技术面，那么恭喜你，你离升职加薪、出任CEO、迎娶白富美、走向人生巅峰又进了一步。但是还没有到谈薪资待遇的时候，最后还有一个考验：HR面试。基本所有的大公司都有这一轮的面试，不要小看HR面试，很多公司的HR对于面试者都有一票否决权的—-即使前面的面试对你的评价再高。所以，这轮的面试也必须重视起来，HR面试主要问的是几点： 简历中写的过去工作经历的离职原因 当前公司薪资待遇 期望能到怎样的一家公司 个人未来的发展方向我专门提一下第2点。可能有人比较排斥也不想说这个，我个人倒是持开放状态，问了就说了，当然一些的夸大还是必要的，当前公司薪资待遇多报个一千块钱完全没问题（毕竟是一家互联网公司总多多少少有些补贴啊什么的嘛）。因为这和你在新公司能拿到的薪水关系不大，新公司能拿到的薪水的决定因素是整个公司的薪资情况以及根据你的面试情况在公司的定位，都是有固定的薪资范围的。HR问这个主要也就是心里有个数并且看你是否诚信—-有些公司入职时会要求你提供最近一家单位的银行流水号。HR面试就说到这里了，总结起来其实就是四个字：滴水不漏。整个面试过程态度积极向上，不要有任何悲观消极的态度（尤其在谈到以前公司情况的时候，即使有再多的不满），就不会有问题。 关于面试心态这个嘛，LZ其实在公司也面试过几个人，一半以上的面试者回答问题的时候都属于那种双腿发抖、声音颤抖的类型。在LZ看来这大可不必并且这还是扣分项，回答问题的时候最最基本的两个要求： 不紧不慢，平心静气 条理清晰表达能力绝对是面试的时候重要的考察项目。咱们做的是程序员这一行，讲究的是团队协作，不是写作、画画，一支笔、一个人就行了，一个表达能力不行的程序员，要来又有什么用呢？除此之外，就是保持良好的心态。古语说得好，只要功夫深，铁杵磨成针，面试的成功与否，在于平时的积累，临时抱抱佛脚，看两道面试题是没有用的，只要平时足够努力，成功是水到渠成的事情，平时不怎么研究技术的，那也就是个听天由命的事情，只要充分地展示平时自己的所学就可以了。因此在我看来，不要把面试当作面试，当做一次技术交流，把面试的心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己，这样就会平和多了，即使失败也不会有太多失望的感觉。另外，如果平时自己热衷于研究技术的朋友，真的要有自信，不要觉得别人面试你别人就比你厉害。面试官未必比你优秀，他问的问题往往都是他平时研究得比较多的问题，你一样有很多自己的研究面试官未必知道。 关于Java网上常看到一种说法：Java比较简单。某种程度上这会打击Java程序员的信心—-原来咱们平时用的是这种小儿科的玩意儿啊，在我看来这种想法大可不必，这一部分我来讲讲对于这个话题的看法。这种说法有些片面，得分开两部分来看，我用四个自总结一下就是：易学难精。 1、易学部分Java易学我认为有两部分的原因： 很多培训公司包括大四的学生找工作都会学习Java，绝大多数是因为易学。Java从C/C++发展而来，感谢前人的智慧，它消除了C/C++中最复杂和让人困惑的语法、它消除了平台的差异性、它不需要用户手动释放内存空间、它避免了Java程序员和本地语言的交互，让程序员只需要专注于语法层面和应用层面 Java作为一门面向对象的语言，在企业级开发中体现出了它无与伦比的特性，整个开发流程比较固定化、模块化，需求分析起来也相对容易。我举个自己以前的例子吧，我在大一学习C语言的时候，用C语言写了一个图书管理系统写了2000行+的代码，大四学了C++之后，用面向对象的语言C++取代面向过程的语言C语言重新写了一个功能相似的图书管理系统，只写了1100行的样子，这就是面向对象的优势2、难精部分接着咱们聊聊难精的部分。Java语言的设计者帮助Java程序员做了这么多事情，这有利也有弊。有利的部分前面已经说过了，让Java易学，不过有弊的部分同样明显。假如在应用运行过程中遇到了语法层面和应用层面之外的错误，应当如何处理？比如线上环境出现内存溢出怎么办？GC时间过长怎么办？IO长时间没反应怎么办？方法抛出莫名其妙的异常怎么办？ 凡此种种，绝不是一名只会写几个if…else…的Java程序员就可以解决的，这需要大量的经历、大量的实践、大量对Java底层实现细节的研究，而这往往是最难、最考验Java程序员的部分，一些人根本就不想往深去研究，另外一些人研究了一点点就研究不下去了。 Java为什么难精？就是这个原因。除非你水平特别高，否则五年工作经验以下的Java程序员在简历上写”精通Java”绝对是一件非常愚蠢的事情。 结语文章写到这里，感觉有点像鸡汤文了，那就以最后的鸡汤作为结尾吧。在以前博客园的一篇文章中，讲到了奔三程序员的困惑，大致说的是三十岁之后程序员要转行之类的云云，LZ在博文中留下了如下的评论： 就以这段话自勉、共勉吧。越努力、越幸运，如果你不是官二代、富二代、红二代，那么请记住：勤奋才是改变你命运的唯一捷径。 我不能保证写的每个地方都是对的，但是至少能保证不复制、不黏贴，保证每一句话、每一行代码都经过了认真的推敲、仔细的斟酌。每一篇文章的背后，希望都能看到自己对于技术、对于生活的态度。 我相信乔布斯说的，只有那些疯狂到认为自己可以改变世界的人才能真正地改变世界。面对压力，我可以挑灯夜战、不眠不休；面对困难，我愿意迎难而上、永不退缩。 其实我想说的是，我只是一个程序员，这就是我现在纯粹人生的全部。","categories":[{"name":"效率","slug":"效率","permalink":"https://www.iteway.com/categories/效率/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://www.iteway.com/tags/转载/"},{"name":"面试经验","slug":"面试经验","permalink":"https://www.iteway.com/tags/面试经验/"}],"keywords":[{"name":"效率","slug":"效率","permalink":"https://www.iteway.com/categories/效率/"}]},{"title":"正则表达式入门","slug":"正则表达式入门","date":"2018-01-12T06:42:45.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/12/正则表达式入门/","link":"","permalink":"https://www.iteway.com/2018/01/12/正则表达式入门/","excerpt":"正则表达式: 又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。","text":"正则表达式: 又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。 本文为好友授权转载,原地址为http://blog.csdn.net/sevenlater/article/details/50708153 1. 正则表达式介绍1.1 概念解释正则表达式: 又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。 1.2 引擎DFA传统型NFAPOSIX NFA详细介绍还是继续看百度百科吧 (＞﹏＜) 2. 正则表达式使用2.1 表达式总览总览表 2.2 常用元字符2.2.1 内容性字符 字符 理解 .(点) 匹配任意单个字符。 \\w 单词字符，大多数情况下可等同[A-Za-z0-9_],有得引擎可匹配中文，有的不可以，如果在特殊情况下需要进行测试 \\d 数字，等同[0-9] \\b 单词边界，即排除\\w以外的字符 \\W \\D \\w, \\d 互斥集合\\s 空白字符，等价与[\\f\\n\\r\\t\\v], 互斥集合\\S 2.2.2 功能性字符 table th:first-of-type { width: 20%; } 字符 理解 [] 区间段，比如[A-Fa-f0-7]、[aui391]，前后字符ascii码值大小不可颠倒。 ^ 匹配字符开始的位置。 如果在[]里使用则表示匹配字符不再区间内，例如[^\\d]标识匹配除\\d以外的字符。 $ 匹配字符的结束位置。 + 表示表达式出现1次或重复多次; ? 表示表达式出现0次或1次; * 表示表达式出现任意次数 {n} 表示出现n次， {n, m} 表示出现n到m次， {n,} 出现大于n次 \\ 转义符 () 分组获取，可使用1…99(最大数百度百科上是9)获取到分组匹配的结果，具体可以看总览表。 逻辑或 表达式的顺序会影响匹配结果，会将最先匹配到的结果返回 (?=pattern) 非获取匹配，匹配单词中的一部分，该匹配部分紧邻后部分需要符合pattern表达式 (?!pattern) 非获取匹配，匹配单词中的一部分，该匹配部分紧邻后部分不符合pattern表达式 (?&lt;=pattern) 非获取匹配，匹配单词中的一部分，该匹配部分紧邻前部分需要符合pattern表达式 (? 非获取匹配，匹配单词中的一部分，该匹配部分紧邻前部分不符合pattern表达式 2.3 使用技巧正则表达式不支持逻辑计算。编写正则表达式的思路： 观察需要匹配的文本特点和规律。 尝试性编写正则表达式，由简入深的编写。 反复测试正则表达式和完善表达式。 单词匹配单词列表 12345678910111213house write first so these her long picture point animal again us try 查找长度5，第二个字符是o的单词 .o…(这样匹配的时候会匹配上部分文本，以下有解决方法) 第二位是o或i的单词 .[oi]…该表达式会匹配picture、animal的部分，解决这个问题可以在表达式两边加上\\b, 结果\\b.[oi]…\\b 子表达式和重复匹配 子表达式是表示一个复杂匹配的单元，使用()括起来的一组复杂的正则表达式。 这里写一个正则来匹配正确的IP地址作为。 12((\\d|[12]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.)((\\d|[12]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.)((\\d|[12]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.)(25[0-5]|1\\d\\d|2[0-4]\\d|[12]\\d|\\d)等价于 ((\\d|[12]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.)&#123;3&#125;(25[0-5]|1\\d\\d|2[0-4]\\d|[12]\\d|\\d) 以上(\\d|[12]\\d|1\\d\\d|2[0-4]\\d|25[0-5])和((\\d|[12]\\d|1\\d\\d|2[0-4]\\d|25[0-5]).)是子表达式。 回溯引用回溯引用需要将要匹配的表达式分组。以下给出两个示例。匹配Html的中的h标签的文本段落 1234&lt;h1&gt;h1段落&lt;/h1&gt;&lt;h1&gt;h1段落&lt;/H1&gt;&lt;h2&gt;h21段落&lt;/h1&gt;&lt;h2&gt;h2段落&lt;/h2&gt; 正确匹配的正则表达式&lt;([Hh][1-6])&gt;.*&lt;/\\1&gt; 其中\\1就是回溯的([Hh][1-6])表达式。 查找文本中的相邻重复单词文本 12This is a block of of text, serveral words here are are repeated, and and they should not be. 表达式[ ](\\w+)[ ]+\\1，会 将以上文本中的of of 、 are are和and and查找出来。 回溯替换，以下使用js代码作为示例了 1234var str = '2016-02-16';var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var ret = str.replace(reg, \"$1-$3-$2\");console.log(ret); 贪婪匹配和非贪婪匹配 贪婪匹配，尽可能多的匹配文本，正则表达式默认启用的就是贪婪模式， +和都是贪婪匹配的字符；而非贪婪匹配，则是尽可能少的匹配文本，启用非贪婪模式则使用*?。 文本aaaaa使用a+（贪婪模式）则会匹配整段文本而使用a+?只则匹配文本中的单个a字符; 123html &lt;div&gt;第一段文本html内容&lt;/div&gt;&lt;div&gt;第二段html内容&lt;/div&gt; &lt;div&gt;.*&lt;/div&gt;表达式会匹配整段代码，即贪婪模式。 &lt;div&gt;.*?&lt;/div&gt;表达式只会匹配 &lt;div&gt;第一段文本html内容&lt;/div&gt;，即非贪婪模式。 3常用正则表达式 规则 正则表达式语法 一个或多个汉字 ^[\\u0391-\\uFFE5]+$ 邮政编码 ^[1-9]\\d{5}$ QQ号码 ^[1-9]\\d{4,10}$ 邮箱 1^[a-zA-Z_]&#123;1,&#125;[0-9]&#123;0,&#125;@(([a-zA-z0-9]-*)&#123;1,&#125;\\.)&#123;1,3&#125;[a-zA-z\\-]&#123;1,&#125;$ 用户名 （字母开头 + 数字/字母/下划线） 1^[A-Za-z][A-Za-z1-9_-]+$ 手机号码 12 ^1[3|4|5|8][0-9]\\d&#123;8&#125;$ URL ^((http|https)://)?([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 18位身份证号 1^(\\d&#123;6&#125;)(18|19|20)?(\\d&#123;2&#125;)([01]\\d)([0123]\\d)(\\d&#123;3&#125;)(\\d|X|x)?$","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.iteway.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.iteway.com/tags/正则表达式/"}],"keywords":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.iteway.com/categories/正则表达式/"}]},{"title":"番茄工作法书评:方法是极好的,首先要静心自律","slug":"番茄工作法书评-方法是极好的,首先要静心自律","date":"2018-01-02T16:00:00.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/03/番茄工作法书评-方法是极好的,首先要静心自律/","link":"","permalink":"https://www.iteway.com/2018/01/03/番茄工作法书评-方法是极好的,首先要静心自律/","excerpt":"番茄工作法书评:方法是极好的, 首先要静心自律 ,然后再按照其中的方法, 提取出适合自己的方法 ,祝大家有一个有序的高效的生活","text":"番茄工作法书评:方法是极好的, 首先要静心自律 ,然后再按照其中的方法, 提取出适合自己的方法 ,祝大家有一个有序的高效的生活 一、心态准备在阅读番茄工作法之前,我的工作生活是无规律和无序,更是效率低下的,效率低下也是令人急躁的事情,偶然间发现图灵社区有本番茄工作法,于是买来看看,拿到这本书的时候当然是看别人对它的评价了,增强自己学习的信心嘛. 二、理论准备于是在心底暗喜,信心大增.对于懒人来说,随时要为自己的行动准备好一个相关的哲理吧!当时突然想到了两个道理第一个:事情虽然很多但是要一件一件的做.第二个:首先要做好第一个道理的第一件事情. 三、开始行动就这样开始学习了番茄工作法,番茄工作法最主要的教会人的就是:有序的做事情,而且将这种有序变成自己的一种习惯.&lt;&lt;番茄工作法&gt;&gt;提供了一种有序-有效的方法:首先要按照重要or紧急列举要做的事情清单,接下来就是有效的去执行,用一段连续不间断的时间,去专门的做某一件事情.总体来说番茄工作法很简单，书的内容总结出来也就很简单的几条：清单：记录自己要做的事情.时间：用固定的时间做完一件事情，休息5分钟，做不完就再用固定的一段时间做，避免不必要的间段总结：总结自己的做法并且改进 四、收获与建议然后我用番茄工作法,执行了一天之后,发现自己做的事情,比没有学习番茄工作法之前做的更多了,而且更有效了,这种有效性令我感觉十分的惊喜,毕竟那么多年效率一直是很低的,做的事情也是那么的少.同时大家可以用一种效率工具:比如滴答清单之类的,来记录自己要做的事情,有时候软件也是一种累赘.自己也可以用网上的协同工具来做记录和工作内容状态切换如:teambation 五、读书笔记第一章读书笔记思维导图 第二章读书笔记思维导图 第三章读书笔记思维导图 相关图书[番茄工作法图灵地址][http://www.ituring.com.cn/book/1514] 2016.1.17今天突发奇想,想到了一个执行番茄工作法的工具,大家看看,可以提出自己的建议一个底板上有几个槽位,槽位固定在底板上,然后挂在自己的工位或者床头,标签 用贴纸代替,可以重复利用底板,完成了今天的内容,标签可以放在另外一个本子里做数据收集工作,槽位可以做重要性调整 然而,转念一想,现在有那么多乐于奉献的朋友,做出了很多番茄工作法的软件和插件,我这种想法太原始了,就当是活跃下思维.就在这推荐几个番茄工作法的软件和插件吧. chrome插件:Strict Workflow (实践番茄工作法：工作时屏蔽浪费时间的网站，休息时允许访问。)微信小程序:番茄工作法 (有雨声,能使人静下心来工作学习)软件: 番茄土豆 (能有效记录和统计任务) 任务清单:Trello其他的大家各抒己见吧,适合自己的,自己觉得好才是正道","categories":[{"name":"效率","slug":"效率","permalink":"https://www.iteway.com/categories/效率/"}],"tags":[{"name":"番茄工作法","slug":"番茄工作法","permalink":"https://www.iteway.com/tags/番茄工作法/"},{"name":"思维导图","slug":"思维导图","permalink":"https://www.iteway.com/tags/思维导图/"}],"keywords":[{"name":"效率","slug":"效率","permalink":"https://www.iteway.com/categories/效率/"}]},{"title":"Linux基本命令:cd、Tab、pwd、mkdir、rmdir","slug":"一-、Linux基本命令-cd、Tab、pwd、mkdir、rmdir","date":"2017-12-31T16:00:00.000Z","updated":"2018-01-19T08:52:18.000Z","comments":true,"path":"2018/01/01/一-、Linux基本命令-cd、Tab、pwd、mkdir、rmdir/","link":"","permalink":"https://www.iteway.com/2018/01/01/一-、Linux基本命令-cd、Tab、pwd、mkdir、rmdir/","excerpt":"cd 切换目录–Change Directorycd ~ 表示回到自己的主文件夹cd .. 表示去上一层目录cd - 表示回到刚才那个目录","text":"cd 切换目录–Change Directorycd ~ 表示回到自己的主文件夹cd .. 表示去上一层目录cd - 表示回到刚才那个目录 12345678[root@HadoopMaster src]# cd [root@HadoopMaster ~]# cd /usr[root@HadoopMaster usr]# cd ~[root@HadoopMaster ~]# cd .. [root@HadoopMaster ~]# cd /usr/local/redis-2.8.13 [root@HadoopMaster redis-2.8.13]# cd .. [root@HadoopMaster local]# cd /usr/local/redis-2.8.13 [root@HadoopMaster redis-2.8.13]# Tab–快速 完整的补全目录或者代码pwd–显示目前所在的目录12[root@HadoopMaster redis-2.8.13]# pwd/usr/local/redis-2.8.13 mkdir –创建文件夹[-mp] 目录名称-m 设置默认的权限-p 可以自行创建多层目录 12345[root@HadoopMaster Desktop]# mkdir test[root@HadoopMaster Desktop]# lldrwxr-xr-x. 2 root root 4096 Aug 14 10:11 test[root@HadoopMaster Desktop]# mkdir -p test/test2/test3[root@HadoopMaster Desktop]# mkdir -p test/test2/test4 test2下面有两个文件夹：test3 test4 rmdir–删除文件夹[-p] 目录文件-p 连同上层空的目录页也一起删除 12[root@HadoopMaster Desktop]# mkdir test1[root@HadoopMaster Desktop]# rmdir test1 只能删除空的文件夹,而且连同上层空的一起删除 123[root@HadoopMaster Desktop]# rmdir -p test/test2/test4rmdir: failed to remove directory `test/test2': Directory not empty[root@HadoopMaster Desktop]# rmdir -p test/test2/test3","categories":[],"tags":[],"keywords":[]}]}